# 第三章。密码学和技术基础

在这一章中，你将被介绍到密码学的概念、理论和实践方面。将更加关注与区块链技术特别相关的方面。此外，还将讨论金融市场的概念，以便为后面章节的内容提供基础。

还将向您介绍加密算法的实际实现，以便您可以实际体验加密功能。为此，使用了 **OpenSSL** 命令行。

在开始理论基础之前，OpenSSL 的安装将在下一节中讨论，这样您可以在阅读理论材料的同时做一些实际工作。

在 Ubuntu Linux 发行版上，OpenSSL 通常已经可用；但是，可以使用以下命令安装它:

```
$ sudo apt-get install openssl

```

在接下来的章节中，首先讨论理论基础，然后介绍相关的实际实验。

# 简介

密码学是一门在敌人面前保证信息安全的科学。它提供了一种在假定拥有无限资源的对手面前进行安全通信的方法。密码用于加密数据，因此如果被对手截获，在没有解密的情况下，数据对他们来说毫无意义，解密需要密钥。

密码术通常用于提供保密服务。就其本身而言，它不能被认为是一个完整的解决方案，而是作为一个更大的安全系统中的一个关键构件来解决安全问题。

密码学提供各种安全服务，如**机密性、完整性、认证**、(实体认证和数据来源认证)和**不可否认性**。此外，在各种安全系统中也需要问责制。

在进一步讨论加密技术之前，需要先解释一些数学术语和概念，以便充分理解本章后面提供的材料。下一节将介绍这些概念。应当注意，本节旨在作为基本介绍。用证据和相关背景来解释所有这些术语需要相当复杂的数学，这超出了本书的范围。关于这些主题的更多细节可以在任何标准数论、代数或密码学教科书中找到。

## 数学

由于密码学的主题是以数学为基础的，本节将介绍一些基本概念，这些概念将帮助你理解本章后面的概念。

### 设定

集合是不同对象的集合，例如， *X= {1，2，3，4，5}* 。

### 组

群是一个交换集合，它有一个组合集合中两个元素的运算。分组操作是封闭的，并且与定义的标识元素相关联。此外，集合中的每个元素都有一个逆元素。闭合(closed)意味着，例如，如果元素 A 和 B 在集合中，那么在对元素执行运算之后得到的元素也在集合中。关联意味着元素的分组不会影响操作的结果。

### 字段

域是包含加法群和乘法群的集合。更准确地说，集合中的所有元素形成一个加法和乘法组。它满足加法和乘法的特定公理。对于所有的群运算，分配律也适用。该定律规定，即使任何项或因子被重新排序，也会产生相同的和或积。

### 有限域

有限域是具有有限元素集的域。也称为伽罗瓦域，这些结构在密码学中特别重要，因为它们可以用来产生精确且无错误的算术运算结果。例如，在椭圆曲线密码中使用素数有限域来构造离散对数问题。

### 订单

这是一个字段中元素的数量。它也被称为字段的基数。

### 主要字段

这是一个有素数个元素的有限域。它有特定的加法和乘法规则，域中每个非零元素都有一个逆。模 *p* 进行加法和乘法运算。

### 戒指

如果在一个阿贝尔群上可以定义一个以上的运算，那么这个群就成为一个环。还需要满足某些属性。环必须具有闭包、结合和分配性质。

### 环状基团

循环群是一种可以由称为群生成器的单个元素生成的群。换句话说，如果对组中的特定元素重复应用组操作，则可以生成组中的所有元素。

### 阿贝尔群

当集合的元素上的运算是可交换的时，就形成了阿贝尔群。交换律基本上就是改变元素的顺序不影响运算的结果，比如 *A X B = B X A* 。

### 模运算

也称为时钟算术，模算术中的数字在达到某个固定数时会回绕。这个固定数是一个称为模数的正数，所有的运算都是针对这个固定数进行的。与时钟类似，数字从 1 到 12。当它达到 12 时，数字 1 又开始了。换句话说，这种算法处理除法运算后的余数。例如，50 mod 11 是 6，因为 50 / 11 剩下 6 的余数。

这就完成了一些数学概念的基本介绍；在下一节中，将向您介绍密码学。

## 密码学

如前所述，加密技术提供了各种安全服务，这里将讨论这些安全服务。

## 保密性

机密性是保证信息只对授权的实体可用。

## 诚信

完整性是对信息仅可由授权实体修改的保证。

## 认证

身份验证为实体的身份或消息的有效性提供了保证。这里讨论了两种类型的认证。

### 实体认证

实体认证是对实体当前参与并活跃在通信会话中的保证。传统上，用户会获得一个用户名和密码，用于访问他们正在使用的平台。这被称为单因素认证，因为只有一个因素，即*你知道的东西*，即密码和用户名。由于各种原因，这种类型的认证不是很安全，例如密码泄露；因此，现在通常使用附加因素来提供更好的安全性。如果只使用两种方法，则使用其他技术进行用户身份验证称为多因素身份验证或双因素身份验证。如果使用两个以上的因素进行身份认证，则称为多因素身份认证。这里描述了各种因素:

1.  第一个因素是您拥有的东西，比如硬件令牌或智能卡。在这种情况下，除了登录凭据之外，用户还可以使用硬件令牌来访问系统。这通过要求两个认证因素来提供保护。有权访问硬件令牌并知道登录凭据的用户将能够访问系统。为了获得对系统的访问，这两个因素都应该可用，从而使该方法成为双因素身份验证机制。
2.  第二个因素是你是什么，它使用生物特征来识别用户。在这种方法中，用户使用指纹、视网膜、虹膜或手的几何形状来提供额外的认证因素。这样，可以确保在认证机制期间用户确实在场，因为生物特征对于个人是唯一的。然而，为了确保高度的安全性，需要小心实施，因为一些研究表明，在某些情况下可以绕过生物识别系统。

### 数据来源认证

也称为消息身份验证，这是对信息来源进行验证的一种保证。数据来源认证意味着数据完整性，因为如果来源得到证实，那么数据一定没有被更改。各种方法，如**消息认证码** ( **MACs** )和数字签名是最常用的。这些术语将在本章后面详细解释。

## 不可否认

不可否认性是确保实体不能通过提供不可伪造的证据来否认先前的承诺或行为。它是一种安全服务，提供特定操作已经发生的不可伪造的证据。在有争议的情况下，该属性是非常必要的，在这种情况下，实体否认了所执行的动作，例如，在电子商务系统上下订单。这项服务在电子交易中生成加密证据，以便在发生争议时，可以将其用作行动的确认。多年来，不可否认性一直是一个活跃的研究领域。电子交易中的争议是一个常见的问题，有必要解决这些问题，以提高消费者对服务的信任程度。

不可否认协议通常在通信网络中运行，用于提供网络上的实体(发起者或接收者)已经采取行动的证据。在这种情况下，有两种通信模型可用于将消息从始发方 *A* 传送到接收方 *B* :

1.  消息直接从发起者 *A* 发送到接收者 *B* 。
2.  消息从始发者 *A* 发送到递送代理，然后递送代理将消息递送到接收者 *B* 。

不可否认协议的主要要求是公平性、有效性和及时性。在许多情况下，交易中涉及多个参与者，而不是只有两方。例如，在电子交易系统中，可能会有许多实体，如清算代理、经纪人和交易商参与到一个交易中。在这种情况下，双方不可否认协议是不合适的。为了解决这个问题**多方不可否认协议** ( **MPNR** )已经被开发出来。

## 问责制

责任是确保影响安全的行为可以追踪到责任方。这通常由系统中的日志记录和审计机制提供，在这些系统中，由于业务的性质需要进行详细的审计，例如在电子交易系统中。详细的日志对于跟踪实体的操作至关重要，例如，当交易被放入带有日期和时间戳的审计记录中时，实体的身份被生成并保存在日志文件中。该日志文件可以选择加密，可以是数据库的一部分，也可以是系统上的独立 ASCII 文本日志文件。

# 密码原语

密码原语是安全协议或系统的基本构件。在下一节中，将向您介绍对于构建安全协议和系统至关重要的加密算法。**安全协议**是通过利用适当的安全机制来实现所需安全目标的一组步骤。

各种类型的安全协议正在使用中，例如**认证协议**、**不可否认协议**和**密钥管理协议**。

下图显示了一个通用加密模型:

![Cryptographic primitives](Images/B05975_03_01.jpg)

显示通用加密和解密模型的模型

在上图中， **P** 、 **E** 、 **C** 和 **D** 分别代表明文、加密、密文和解密。此外，基于前面显示的模型，有必要解释各种概念，如实体、发送者、接收者、对手、密钥和通道。

*   **实体**:发送、接收数据或对数据执行操作的人或系统
*   **发送方**:发送方是传输数据的实体
*   **接收方**:接收方是接收数据交付的实体
*   **对手**:这是一个试图绕过安全服务的实体
*   **密钥**:密钥是一些用于加密或解密数据的数据
*   **信道**:信道提供了实体间通信的媒介

密码学主要分为两大类，即对称密码和非对称密码。

## 对称加密

对称加密指的是一种加密技术，用于加密数据的密钥与用于解密数据的密钥相同，因此也称为共享密钥加密。在通信双方交换数据之前，必须建立或商定密钥。这就是它也被称为**密钥加密**的原因。

有两种对称密码，流密码和块密码。**数据加密标准** ( **DES** )和**高级加密标准** ( **AES** )是分组密码的常见例子，而 RC4 和 A5 是常用的流密码。

### 流密码

这些密码是加密算法，使用密钥流对纯文本逐位应用加密算法。有两种类型的流密码:同步和异步。同步流密码的密钥流仅依赖于密钥，而异步流密码的密钥流也依赖于加密数据。

在流密码中，加密和解密基本上是相同的功能，因为它们是简单的模 2 加法或 XOR 运算。流密码的关键要求是密钥流的安全性和随机性。已经开发了各种技术来生成随机数，所有密钥生成器都必须是密码安全的，这一点至关重要:

![Stream ciphers](Images/B05975_03_02.jpg)

流密码的操作

### 分组密码

这些是将待加密的文本(纯文本)分解成固定长度的块并逐块应用加密的加密算法。分组密码通常使用一种称为 Fiestel 密码的设计策略来构建。最近的分组密码，如 AES (Rijndael)，已经使用称为**替换-置换网络** ( **SPN** )的替换和置换的组合来构建。

Fiestel 密码基于 Fiestel 网络，这是由 *Horst Fiestel* 开发的一种结构。这种结构基于组合多轮重复操作以获得期望的密码特性的思想，即混淆和扩散。Fiestel 网络通过将数据分成两个块(左和右)并通过键控循环函数处理这些块来运行。

混淆使得加密文本和明文之间的关系变得复杂。这在实践中是通过替换实现的。例如，明文中的“A”在加密文本中被替换为“X”。在现代加密算法中，使用称为 S 盒的查找表来执行替换。扩散属性以统计方式将纯文本扩散到加密数据上，这确保了即使输入文本中的单个位发生变化，也会导致密文中至少一半(平均)的位发生变化。即使使用相同的密钥创建了许多加密和解密的数据对，也需要混淆来使得查找加密密钥非常困难。实际上，这是通过换位或排列来实现的。

使用 Fiestel 密码的一个主要优点是加密和解密操作几乎是相同的，并且只需要加密过程的反向操作就可以实现解密。DES 是基于 Fiestel 的密码的主要例子:

![Block ciphers](Images/B05975_03_03.jpg)

分组密码的简化运算

分组密码的各种操作模式有**电子码本** ( **ECB** )、**密码分组链接** ( **CBC** )、**输出反馈模式** ( **OFB** )或**计数器模式** ( **CTR** )。这些模式用于指定加密函数应用于纯文本的方式。这些模式将在本节稍后解释，但这里只介绍前四类分组密码加密模式。

#### 块加密模式

在这种模式下，根据使用的密码类型，明文被分成固定长度的块，然后对每个块应用加密功能。

#### 密钥流生成模式

在这种模式下，加密函数生成一个密钥流，然后将其与明文流进行异或运算，以实现加密。

#### 消息认证模式

在这种模式下，消息认证码是作为加密函数的结果而计算的。MAC 基本上是一种提供完整性服务的加密校验和。使用分组密码生成 MAC 的最常见方法是 CBC-MAC，其中链的最后一个块的某个部分被用作 MAC。

#### 加密哈希

哈希函数主要用于将消息压缩成固定长度的摘要。在这种模式下，块密码被用作压缩函数来产生纯文本的散列。

简要讨论了最常见的块加密模式。

#### 电子密码本

这是一种基本的操作模式，在这种模式下，加密数据是通过对每个明文块逐个单独应用加密算法而生成的。这是最简单的模式，但不应在实践中使用，因为它不安全并且会泄露信息:

![Electronic code book](Images/B05975_03_04.jpg)

分组密码的电子码本模式

#### 密码块链接

在这种模式下，每个纯文本块与前一个加密块进行异或运算。CBC 模式使用初始化向量 IV 来加密第一个块。建议随机选择 IV:

![Cipher block chaining](Images/B05975_03_05.jpg)

密码块链接模式

#### 计数器模式

CTR 模式有效地将分组密码用作流密码。在这种情况下，提供与计数器值连接的唯一随机数，以便产生**密钥流**:

![Counter mode](Images/B05975_03_06.jpg)

计数器模式

还有其他的模式，比如**密码反馈模式** ( **CFB** )、**伽罗瓦计数器模式** ( **GCM** )，输出反馈模式，也是在各种场景下使用。

在下一节中，将向您介绍目前占主导地位的分组密码 AES 的设计和机制。首先，将介绍导致新 AES 标准发展的数据加密标准(DES)的一些历史。

## 数据加密标准(DES)

DES 是由美国国家标准与技术研究院(T1)(**NIST**)作为加密的标准算法推出的，并在 20 世纪 80 年代和 90 年代得到主要使用，但由于技术和密码学研究的进步，它并未被证明对暴力攻击具有很强的抵抗力。特别是在 1998 年 7 月，**电子前沿基金会** ( **EFF** )用专用机器破解了 DES。DES 使用的密钥只有 56 位，这引起了一些关注。随着**三重 DES** ( **3DES** )的引入，这个问题得到了解决，它提出使用三个 56 位密钥和相同次数的 DES 算法来使用 168 位密钥，从而使得暴力攻击几乎不可能。但是其他限制，如缓慢的性能和 64 位块大小，是不可取的。

## 高级加密标准(AES)

2001 年，在一次公开竞赛后，一种名为 Rijndael 的加密算法由密码学家*琼·代蒙*和*文森特·里门*发明，在 2001 年被 NIST 标准化为 AES，并进行了微小的修改。到目前为止，还没有发现对 AES 的攻击比暴力破解方法更好。原始 Rijndael 允许 128 位、192 位和 256 位的不同密钥和块大小，但在 AES 标准中，只允许 128 位的块大小。但是，允许 128 位、192 位和 256 位的密钥大小。

### AES 步骤

在 AES 算法处理过程中，一个 4 乘 4 的字节数组被称为*状态*，使用多轮修改。完全加密需要 10 到 14 轮，具体取决于密钥的大小。下表显示了密钥大小和所需的轮数:

![AES steps](Images/B05975_03_56.png)

一旦用密码的输入初始化了状态，为了加密输入，在四个阶段中执行四个操作。这些阶段是`AddRoundKey`、`SubBytes`、`ShiftRows`和`MixColumns`:

1.  在`AddRoundKey`步骤中，状态数组与一个子密钥进行异或运算，这个子密钥是从主密钥中派生出来的。
2.  这是替换步骤，其中使用查找表(S 盒)来替换状态数组的所有字节。
3.  该步骤用于以循环和递增的方式将状态数组中除第一行之外的每一行向左移位。
4.  最后，在这一步中，所有字节以线性方式按列混合。

前面的步骤描述了一轮 AES。在最后一轮(10、12 或 14，取决于密钥大小)，第 4 阶段被替换为`Addroundkey`，以确保前三个步骤不能简单地反转回来:

![AES steps](Images/B05975_03_07.jpg)

AES 框图显示了第 1 <sup class="calibre44">轮和第</sup>轮，最后一轮混合步骤未执行

各种加密货币钱包使用 AES 加密来加密本地存储的数据。特别是在比特币钱包中，使用的是 CBC 模式下的 AES 256。

#### 如何使用 AES 加密和解密的 OpenSSL 示例

```
:~/Crypt$ openssl enc -aes-256-cbc -in message.txt -out message.bin
enter aes-256-cbc encryption password:
Verifying - enter aes-256-cbc encryption password:
:~/Crypt$ ls -ltr
total 12
-rw-rw-r-- 1 drequinox drequinox 14 Sep 21 05:54 message.txt
-rw-rw-r-- 1 drequinox drequinox 32 Sep 21 05:57 message.bin
:~/Crypt$ cat message.bin

```

![An OpenSSL example of how to encrypt and decrypt using AES](Images/B05975_03-2.png)

注意`message.bin`是二进制文件；有时，出于兼容性/互操作性的原因，需要将这个二进制文件编码成文本格式。可以使用以下命令来完成此操作:

```
:~/Crypt$ openssl enc -base64 -in message.bin -out message.b64
:~/Crypt$ ls -ltr
-rw-rw-r-- 1 drequinox drequinox 14 Sep 21 05:54 message.txt
-rw-rw-r-- 1 drequinox drequinox 32 Sep 21 05:57 message.bin
-rw-rw-r-- 1 drequinox drequinox 45 Sep 21 06:00 message.b64
:~/Crypt$ cat message.b64
U2FsdGVkX193uByIcwZf0Z7J1at+4L+Fj8/uzeDAtJE=
:~/Crypt$

```

为了解密 AES 加密的文件，可以使用以下命令。从前面的例子中选取一个`message.bin`的例子:

```
:~/Crypt$ openssl enc -d -aes-256-cbc -in message.bin -out message.dec
enter aes-256-cbc decryption password:
:~/Crypt$ ls -ltr
-rw-rw-r-- 1 drequinox drequinox 14 Sep 21 05:54 message.txt
-rw-rw-r-- 1 drequinox drequinox 32 Sep 21 05:57 message.bin
-rw-rw-r-- 1 drequinox drequinox 45 Sep 21 06:00 message.b64
-rw-rw-r-- 1 drequinox drequinox 14 Sep 21 06:06 message.dec
:~/Crypt$ cat message.dec
datatoencrypt
:~/Crypt$

```

敏锐的读者会注意到没有提供初始化向量，即使它在除 ECB 之外的所有块加密操作模式中都需要。原因是 OpenSSL 自动从给定的密码中导出初始化向量。用户可以使用开关指定初始化向量:

```
-K/-iv    ,  (Initialization Vector) should be provided in Hex.

```

为了从 base64 解码，使用以下命令。以上例中的`message.b64`文件为例:

```
:~/Crypt$ openssl enc -d -base64 -in message.b64 -out message.ptx
:~/Crypt$ ls -ltr
-rw-rw-r-- 1 drequinox drequinox 14 Sep 21 05:54 message.txt
-rw-rw-r-- 1 drequinox drequinox 32 Sep 21 05:57 message.bin
-rw-rw-r-- 1 drequinox drequinox 45 Sep 21 06:00 message.b64
-rw-rw-r-- 1 drequinox drequinox 14 Sep 21 06:06 message.dec
-rw-rw-r-- 1 drequinox drequinox 32 Sep 21 06:16 message.ptx

```

![An OpenSSL example of how to encrypt and decrypt using AES](Images/B05975_03_40.png)

OpenSSL 支持多种类型的密码；您可以根据前面提供的示例来探索这些选项。下面的屏幕截图显示了支持的密码类型列表:

![An OpenSSL example of how to encrypt and decrypt using AES](Images/image_03_008.jpg)

显示 OpenSSL 中可用的丰富库选项的屏幕截图。

# 非对称加密

非对称加密指的是一种加密技术，用于加密数据的密钥不同于用于解密数据的密钥。也称为公钥加密，它使用公钥和私钥来分别加密和解密数据。各种非对称加密方案正在使用中，例如 RSA、DSA 和 El-Gammal。

下图显示了公钥加密的概述:

![Asymmetric cryptography](Images/B05975_03_09.jpg)

使用公钥/私钥加密解密

该图解释了发送方如何使用接收方的公钥加密数据，然后通过网络传输给接收方。一旦到达接收方，就可以使用接收方的私钥对其进行解密。这样，私钥保留在接收方，不需要共享密钥来执行加密和解密，而对称加密就是这种情况。

另一张图显示了如何使用公钥加密来验证接收方收到的消息的完整性。在这个模型中，发送方使用他们的私钥对数据进行签名，然后将消息传递给接收方。一旦接收方收到消息，就可以用发送方的公钥验证其完整性。注意，在这个模型中没有执行加密。此模型仅用于消息身份验证和验证目的:

![Asymmetric cryptography](Images/B05975_03_10.jpg)

一种公钥密码签名方案的模型

公钥密码系统提供的安全机制包括密钥建立、数字签名、识别、加密和解密。

密钥建立机制与允许在不安全的信道上建立密钥的协议设计有关。使用数字签名可以提供不可否认服务，这是许多情况下非常需要的属性。有时，重要的是不仅要认证用户，还要识别交易中涉及的实体；这也可以通过数字签名和挑战应答协议的组合来实现。最后，提供机密性的加密机制也可以使用公钥密码系统来实现，例如 RSA、ECC 或 El-Gammal。

与对称密钥算法相比，公钥算法的计算速度较慢。因此，它们通常不用于加密大型文件或需要加密的实际数据。它们通常用于交换对称算法的密钥，一旦安全地建立了密钥，就可以使用对称密钥算法来加密数据。

公钥密码算法基于各种潜在的数学问题。这里描述了三种主要的不对称算法。

## 整数因式分解

这些方案基于大整数很难分解的事实。RSA 是这种算法的典型例子。

## 离散对数

这是基于模运算中的一个问题，即很容易计算模函数的结果，但是在计算上找生成器的指数是不可行的。换句话说，从结果中找到输入是极其困难的。这是一个单向函数。

例如，考虑以下等式:

<sup class="calibre44">3<sup class="calibre44">2</sup>mod 10 = 9</sup>

现在给定 9 求 2，生成器 3 的指数很难。这个难题常用于 **Diffie-Hellman** 密钥交换和数字签名算法。

## 椭圆曲线

这是基于前面讨论的离散对数问题，但是是在椭圆曲线的情况下。椭圆曲线是域上的代数三次曲线，可以用这里所示的方程来定义。该曲线是非奇异的，这意味着它没有尖点或自交。它有两个变量 a，b 和一个无穷远点。

![Elliptic curves](Images/image_03_012.jpg)

这里， *a* 、 *b* 是可以具有各种值的整数，并且是在其上定义椭圆曲线的域的元素。椭圆曲线可以定义在实数、有理数、复数或有限域上。出于加密目的，使用素数有限域上的椭圆曲线来代替实数。此外，素数应该大于 3。通过改变 *a* 、 *b.* 的值，可以生成不同的曲线

最常用的基于椭圆曲线的密码系统是**椭圆曲线数字签名算法** ( **ECDSA** )和**椭圆曲线 Diffie-Hellman** ( **ECDH** )密钥交换。

# 公钥和私钥

为了理解公钥密码学，首先需要了解的概念是公钥和私钥的概念。

顾名思义，私钥基本上是一个由用户秘密持有的随机生成的数字。私钥需要得到保护，并且不应该允许对该密钥进行未经授权的访问；否则，公钥加密的整个方案将受到危害，因为这是用于解密消息的密钥。根据所用算法的类型和类别，私钥可以有不同的长度。例如，在 RSA 中，通常使用 1024 位或 2048 位的密钥。1024 位密钥大小不再被认为是安全的，建议在实践中至少使用 2048 位。

公钥是私钥-公钥对的公共部分。公钥是公开可用的，并由私钥所有者发布。然后，任何想要向公钥的发布者发送加密消息的人都可以通过使用发布的公钥加密该消息并将其发送给私钥的持有者来这样做。没有其他人能够解密该消息，因为相应的私钥被预定的接收者安全地持有。一旦接收到公钥加密的消息，接收者就可以使用私钥解密该消息。关于公钥有一些问题，比如公钥的真实性和发行者的身份。

## 的话

这里讨论 RSA 的描述。RSA 于 1977 年由*罗恩·里维斯特*、*阿迪·萨莫尔*和*伦纳德·阿德尔曼*发明，因此得名 RSA。这是基于整数因式分解问题，其中两个大质数的乘法很容易，但很难将其分解回两个原始数。

RSA 算法工作的关键在于密钥生成过程。RSA 密钥对是通过执行此处描述的步骤生成的。

模数生成:

*   选择 *p* 和 *q* 超大素数
*   将 *p* 和 *q* 、 *n=p.q* 相乘生成模数 *n*

生成互质:

*   假设一个数字叫做 *e* 。
*   应该满足一定的条件，即应该大于 1 小于 *(p-1) (q-1)* 。换句话说，e 必须是这样一个数，使得除了 1 之外的任何数都不能被分成 *e* 和 *(p-1) (q-1)* 。这叫互质，即 *e* 是 *(p-1)(q-1)* 的互质。

生成公钥:

*   在步骤 1 中生成的模数和在步骤 2 中生成的 e 是一对，它们一起是公钥。这部分是可以分享给任何人的公共部分；但是， *p* 和 *q* 需要保密。

生成私钥:

*   Private key called d here and is calculated from *p*, *q* and *e*. Private key is basically the inverse of e modulo *(p-1)(q-1)*. In the equation form, it is this:

    *ed = 1 mod(p-1)(q-1)*

通常使用扩展的欧几里德算法计算*d*；这个算法取 *p* 、 *q* 和 *e* 并计算 *d* 。该方案的关键思想是，任何知道 *p* 和 *q* 的人都可以通过应用扩展的欧几里德算法来容易地计算私钥 *d* ，但是不知道 *p* 和 *q* 的值的人不能生成 *d* 。这也意味着 *p* 和 *q* 应该足够大，以使模数 *n* 变得非常难以分解(计算上不可行)。

### 使用 RSA 加密和解密

RSA 使用以下等式来生成密文:

*C = P <sup class="calibre44">e</sup> mod n*

这意味着纯文本 *P* 被提升到 *e* 的次数，然后降低到模 *n* 。

RSA 中的解密由以下等式给出:

*P = C <sup class="calibre44">d</sup> mod n*

这意味着拥有公钥对( *n* ， *e* )的接收者可以通过将 *C* 提升到私钥 *d* 的值，并降低到模 *n* 来解密数据。

### 椭圆曲线密码(ECC)

ECC 基于离散对数问题，该问题基于有限域(伽罗瓦域)上的椭圆曲线。与其他类型的公钥算法相比，ECC 的主要优势在于它需要更小的密钥大小，同时提供与 RSA 相同的安全级别。源于 ECC 的两个值得注意的方案是用于密钥交换的**椭圆曲线 Diffie-Hellman** ( **ECDH** )和用于数字签名的**椭圆曲线数字签名算法** ( **ECDSA** )。它也可以用于加密，但在实践中通常不用于此目的；相反，更常用的是密钥交换和数字签名。由于 ECC 需要更少的操作空间，它在嵌入式平台或存储资源有限的系统中变得非常流行。相比之下，与 RSA 中的 3072 位操作数相比，ECC 中仅使用 256 位操作数就可以实现相同级别的安全性。

#### ECC 背后的数学

为了理解 ECC，对基础数学的基本介绍是必要的。椭圆曲线基本上是一种称为 weierstrass 方程的多项式方程，它在有限域上生成曲线。最常用的领域是所有算术运算都以模 *a* 素数 *p* 执行的地方。椭圆曲线群由有限域上曲线上的点组成。

椭圆曲线可以定义为以下等式:

![Mathematics behind ECC](Images/image_03_017.jpg)

这里， *A* 和 *B* 与一个称为无穷远点的特殊值一起属于一个有限域 *Zp* 或 *FP* (素数有限域)。无穷远点![Mathematics behind ECC](Images/image_03_019.jpg)用于为曲线上的点提供恒等运算。

此外，还需要满足一个条件，以确保前面提到的方程没有重复的根。这意味着曲线是非奇异的。

等式中描述了该条件，这是需要满足的标准要求。更准确地说，这确保了曲线是非奇异的:

![Mathematics behind ECC](Images/image_03_020.jpg)

椭圆曲线的实数表示如下图所示。这是实数上的方程图:

![Mathematics behind ECC](Images/image_03_012.jpg)

椭圆曲线加密中使用的实际曲线是在有限素数域上，但在这里，它们是在实数上显示的，因为当绘制在 *R* 上时，操作变得更容易可视化:

![Mathematics behind ECC](Images/image_03_022.jpg)

实数上的椭圆曲线，a = -3，b = 3

为了构造基于椭圆曲线的离散对数问题，需要一个足够大的循环群。首先，组元素被识别为满足前面等式的一组点。在这之后，需要在这些点上定义组操作。

椭圆曲线上的群运算是点加法和点加倍。点相加是将两个不同的点相加的过程，点加倍意味着将同一个点加到自身上。这两种操作都可以被可视化，如下图所示。

#### 点加法

点添加如下图所示。这是椭圆曲线上点加法的几何表示。在该方法中，通过曲线绘制一条线，该线与曲线相交于下面所示的两点 *P* 和 *Q* ，这产生了曲线和线之间的第三个点。这个点镜像为 *P+Q* ，将加法的结果表示为 *R* 。这在下图中显示为 *P+Q* :

![Point addition](Images/image_03_023.jpg)

R 上可视化的点加法

由用于加法的符号 *+* 表示的群组运算产生以下等式:

P + Q = R

在这种情况下，添加两个点是为了计算曲线上第三个点的坐标:

![Point addition](Images/image_03_024.jpg)

更准确地说，这意味着坐标被添加，如下式所示:

*(* x1，y1) + (x2，y2) = (x3，y3)

点加法的方程式如下:

![Point addition](Images/image_03_025-1.jpg)

![Point addition](Images/image_03_026.jpg)

这里，结果是这样的:

![Point addition](Images/image_03_028.jpg)

上式中的 *S* 描绘了穿过 *P* 和 *Q* 的直线。

此处显示的点加法示例是使用 Certicom 的在线计算器制作的。这个例子展示了有限域*F<sub class="calibre61">23</sub>T3】上方程的加法和解。这与之前显示的示例形成对比，该示例针对实数，仅显示了曲线，但没有方程的解:*

![Point addition](Images/image_03_029.jpg)

使用 Certicom 在线计算器工具增加点数的示例

在示例中，左侧的图表显示了满足此处所示等式的点:

![Point addition](Images/image_03_030.jpg)

在有限域*F<sub class="calibre61">23</sub>T3】上，前面所示的方程有 27 个解。选择 *P* 和 *Q* 相加产生点 *R* 。计算结果显示在右侧，计算第三个点 *R* 。注意这里， *l* 用于描绘穿过 *P* 和 *Q* 的线。*

作为示出图中所示的点如何满足该方程的例子，在 *x = 3* 和 *y = 6* 处选取一个点( *x，y* )。

在方程中使用这些值表明方程确实是满足的。这显示如下:

![Point addition](Images/image_03_031.jpg)

![Point addition](Images/image_03_032.jpg)

![Point addition](Images/image_03_033.jpg)

![Point addition](Images/image_03_034.jpg)

下一节将介绍点加倍的概念，这是可以在椭圆曲线上执行的另一种操作。

#### 点加倍

椭圆曲线上的另一组运算称为点加倍，如下图所示。这是一个 *P* 加入自身的过程。在这种方法中，通过曲线绘制一条切线，如下图所示。获得第二个点，该点位于绘制的切线和曲线的交点处。这个点然后被镜像以产生结果，结果显示为 *2P = P + P* :

![Point doubling](Images/image_03_035.jpg)

表示实数上的点加倍的图形

在点加倍的情况下，等式变成如下:

![Point doubling](Images/image_03_025-2.jpg)

![Point doubling](Images/image_03_026.jpg)

![Point doubling](Images/image_03_028.jpg)

这里， *S* 是通过 *P* 的切线(切线)的斜率。它是上图中显示的顶部的线。在前面的例子中，作为一个简单的例子，曲线是在实数上绘制的，没有显示方程的解。

这里举一个例子，展示了有限域*F<sub class="calibre61">23</sub>T3】上椭圆曲线的解和点加倍。左侧的图表显示了满足等式的点:*

![Point doubling](Images/image_03_030.jpg)

![Point doubling](Images/image_03_041.jpg)

使用 certicom 在线计算器工具加倍点数的示例

如前所示，在右手边，显示了一个计算，该计算在 *P* 被添加到自身(点加倍)之后找到 *R* 。这里没有 *Q* ，相同的点 *P* 用于加倍。注意，在计算中， *l* 用于描绘穿过 *P* 的切线。

在下一节中，将介绍离散对数问题。

## 离散对数问题

ECC 中的离散对数问题是基于这样的思想:在一定条件下，椭圆曲线上的所有点形成一个循环群。在椭圆曲线上，公钥是生成点的随机倍数，而私钥是用于生成倍数的随机选择的整数。换句话说，私钥是随机选择的整数，而公钥是曲线上的一点。离散对数问题用于寻找私钥(一个整数),其中该整数落在椭圆曲线上的所有点内。一个即将到来的方程精确地说明了这一点。考虑一条椭圆曲线 *E* ，有两个元素 *P* 和 *T* 。离散对数问题是求整数 d，其中 *1 < = d < = #E* ，这样:

*P + P +。。。+P = d P = T*

这里， *T* 是公钥(曲线上的点)，d 是私钥。换句话说，公钥是生成器的随机倍数，而私钥是用于生成倍数的整数。 *#E* 表示椭圆曲线的阶，基本上就是指椭圆曲线的循环群中存在的点数。椭圆曲线上的点和无穷远点的组合形成了循环群。

密钥对与椭圆曲线的特定域参数相关联。域参数包括域大小、域表示、来自域的两个元素 *a* 和 *b* 、两个域元素 *Xg* 和 *Yg* 、点 *G* 的阶数 n，其计算为 *G=(Xg，Yg)* 和辅助因子 *h = #E(Fq)/n* 。本节稍后将描述一个使用 OpenSSL 的实际例子。

有各种推荐和标准化的参数可用作 ECC 曲线。这里显示了一个 SECP256K1 规格示例。这是比特币一直使用的规范:

![Discrete logarithm problem](Images/image_03_042.jpg)

取自 http://www.secg.org/sec2-v2.pdf 的 SECP256K1 的规格

这里给出了六元组中所有这些值的解释。

*P* 是指定有限域大小的素数 *p* 。

*a* 和 *b* 是椭圆曲线方程的系数。

*G* 是生成所需子群的基点，也称为生成器。基点可以用压缩或未压缩的形式表示。在实际实现中，不需要存储曲线上的所有点。压缩生成器工作是因为曲线上的点可以通过仅使用 *x* 坐标和 *y* 坐标的最低有效位来识别。

*n* 是子群的阶。

*h* 是子群的余因子。

在下一节中，将展示一个使用 OpenSSL 的示例，以帮助您理解 RSA 的实际应用。

在下一节中，将展示如何使用 OpenSSL 生成 RSA 公钥和私钥对。

### 如何生成公钥和私钥对

首先，展示了如何使用 OpenSSL 生成 RSA 私钥。

#### 私钥

```
~/Crypt$ openssl genpkey -algorithm RSA -out privatekey.pem -pkeyopt rsa_keygen_bits:1024
...............................++++++
....................++++++

```

执行该命令后，会生成一个名为`privatekey.pem`的文件，其中包含生成的私钥。这显示如下:

```
~/Crypt$ cat privatekey.pem
-----BEGIN PRIVATE KEY-----
MIICdgIBADANBgkqhkiG9w0BAQEFAASCAmAwggJcAgEAAoGBAKJOFBzPy2vOd6em
Bk/UGrzDy7TvgDYnYxBfiEJId/r+EyMt/F14k2fDTOVwxXaXTxiQgD+BKuiey/69
9itnrqW/xy/pocDMvobj8QCngEntOdNoVSaN+t0f9nRM3iVM94mz3/C/v4vXvoac
PyPkr/0jhIV0woCurXGTghgqIbHRAgMBAAECgYEAlB3s/N4lJh0l1TkOSYunWtzT
6isnNkR7g1WrY9H+rG9xx4kP5b1DyE3SvxBLJA6xgBle8JVQMzm3sKJrJPFZzzT5
NNNnugCxairxcF1mPzJAP3aqpcSjxKpTv4qgqYevwgW1A0R3xKQZzBKU+bTO2hXV
D1oHxu75mDY3xCwqSAECQQDUYV04wNSEjEy9tYJ0zaryDAcvd/VG2/U/6qiQGajB
eSpSqoEESigbusKku+wVtRYgWWEomL/X58t+K01eMMZZAkEAw6PUR9YLebsm/Sji
iOShV4AKuFdi7t7DYWE5Ulb1uqP/i28zN/ytt4BXKIs/KcFykQGeAC6LDHZyycyc
ntDIOQJAVqrE1/wYvV5jkqcXbYLgV5YA+KYDOb9Y/ZRM5UETVKCVXNanf5CjfW1h
MMhfNxyGwvy2YVK0Nu8oY3xYPi+5QQJAUGcmORe4w6Cs12JUJ5p+zG0s+rG/URhw
B7djTXm7p6b6wR1EWYAZDM9MArenj8uXAA1AGCcIsmiDqHfU7lgz0QJAe9mOdNGW
7qRppgmOE5nuEbxkDSQI7OqHYbOLuwfCjHzJBrSgqyi6pj9/9CbXJrZPgNDwdLEb
GgpDKtZs9gLv3A==
-----END PRIVATE KEY-----

```

#### 生成公钥

由于私钥在数学上与公钥相关联，因此可以从私钥中生成或导出公钥。以前面的私钥为例，公钥可以如下所示生成:

```
:~/Crypt$ openssl rsa -pubout -in privatekey.pem -out publickey.pem
writing RSA key

```

可以使用文件阅读器或任何文本查看器查看公钥，如下所示:

```
:~/Crypt$ cat publickey.pem
-----BEGIN PUBLIC KEY-----
MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCiThQcz8trznenpgZP1Bq8w8u0
74A2J2MQX4hCSHf6/hMjLfxdeJNnw0zlcMV2l08YkIA/gSronsv+vfYrZ66lv8cv
6aHAzL6G4/EAp4BJ7TnTaFUmjfrdH/Z0TN4lTPeJs9/wv7+L176GnD8j5K/9I4SF
dMKArq1xk4IYKiGx0QIDAQAB
-----END PUBLIC KEY-----

```

为了查看关于各种组件的更多细节，例如模数、过程中使用的质数、生成的私钥的指数和系数，可以使用以下命令(由于太大，没有显示完整的输出):

```
:~/Crypt$ openssl rsa -text -in privatekey.pem
Private-Key: (1024 bit)
modulus:
 00:a2:4e:14:1c:cf:cb:6b:ce:77:a7:a6:06:4f:d4:
 1a:bc:c3:cb:b4:ef:80:36:27:63:10:5f:88:42:48:
 77:fa:fe:13:23:2d:fc:5d:78:93:67:c3:4c:e5:70:
 c5:76:97:4f:18:90:80:3f:81:2a:e8:9e:cb:fe:bd:
 f6:2b:67:ae:a5:bf:c7:2f:e9:a1:c0:cc:be:86:e3:
 f1:00:a7:80:49:ed:39:d3:68:55:26:8d:fa:dd:1f:
 f6:74:4c:de:25:4c:f7:89:b3:df:f0:bf:bf:8b:d7:
 be:86:9c:3f:23:e4:af:fd:23:84:85:74:c2:80:ae:
 ad:71:93:82:18:2a:21:b1:d1
publicExponent: 65537 (0x10001)
privateExponent:
 00:94:1d:ec:fc:de:25:26:1d:25:d5:39:0e:49:8b:
 a7:5a:dc:d3:ea:2b:27:36:44:7b:83:55:ab:63:d1:
 fe:ac:6f:71:c7:89:0f:e5:bd:43:c8:4d:d2:bf:10:
 4b:24:0e:b1:80:19:5e:f0:95:50:33:39:b7:b0:a2:
 6b:24:f1:59:cf:34:f9:34:d3:67:ba:00:b1:6a:2a:
 f1:70:5d:66:3f:32:40:3f:76:aa:a5:c4:a3:c4:aa:
 53:bf:8a:a0:a9:87:af:c2:05:b5:03:44:77:c4:a4:
 19:cc:12:94:f9:b4:ce:da:15:d5:0f:5a:07:c6:ee:
 f9:98:36:37:c4:2c:2a:48:01
prime1:
 00:d4:61:5d:38:c0:d4:84:8c:4c:bd:b5:82:74:cd:
 aa:f2:0c:07:2f:77:f5:46:db:f5:3f:ea:a8:90:19:
 a8:c1:79:2a:52:aa:81:04:4a:28:1b:ba:c2:a4:bb:
 ec:15:b5:16:20:59:61:28:98:bf:d7:e7:cb:7e:2b:
 4d:5e:30:c6:59
prime2:
 00:c3:a3:d4:47:d6:0b:79:bb:26:fd:28:e2:88:e4:
 a1:57:80:0a:b8:57:62:ee:de:c3:61:61:39:52:56:
 f5:ba:a3:ff:8b:6f:33:37:fc:ad:b7:80:57:28:8b:
 3f:29:c1:72:91:01:9e:00:2e:8b:0c:76:72:c9:cc:
 9c:9e:d0:c8:39

```

类似地，可以使用以下命令研究公钥。公钥和私钥是 base64 编码的:

```
~/Crypt$ openssl pkey -in publickey.pem -pubin -text
-----BEGIN PUBLIC KEY-----
MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCiThQcz8trznenpgZP1Bq8w8u0
74A2J2MQX4hCSHf6/hMjLfxdeJNnw0zlcMV2l08YkIA/gSronsv+vfYrZ66lv8cv
6aHAzL6G4/EAp4BJ7TnTaFUmjfrdH/Z0TN4lTPeJs9/wv7+L176GnD8j5K/9I4SF
dMKArq1xk4IYKiGx0QIDAQAB
-----END PUBLIC KEY-----
Public-Key: (1024 bit)
Modulus:
 00:a2:4e:14:1c:cf:cb:6b:ce:77:a7:a6:06:4f:d4:
 1a:bc:c3:cb:b4:ef:80:36:27:63:10:5f:88:42:48:
 77:fa:fe:13:23:2d:fc:5d:78:93:67:c3:4c:e5:70:
 c5:76:97:4f:18:90:80:3f:81:2a:e8:9e:cb:fe:bd:
 f6:2b:67:ae:a5:bf:c7:2f:e9:a1:c0:cc:be:86:e3:
 f1:00:a7:80:49:ed:39:d3:68:55:26:8d:fa:dd:1f:
 f6:74:4c:de:25:4c:f7:89:b3:df:f0:bf:bf:8b:d7:
 be:86:9c:3f:23:e4:af:fd:23:84:85:74:c2:80:ae:
 ad:71:93:82:18:2a:21:b1:d1
Exponent: 65537 (0x10001)

```

现在公钥可以公开共享，任何想给我们发送消息的人都可以用公钥加密消息并发送给我们。然后，我们可以使用相应的私钥来解密文件。

### 如何使用 RSA 和 OpenSSL 进行加密和解密

首先，我们将给出一个示例，演示如何使用 RSA 进行加密。

#### 加密

以前面示例中生成的私钥为例，可以构造加密文本文件`message.txt`的命令，如下所示:

```
:~/Crypt$ openssl rsautl -encrypt -inkey publickey.pem -pubin -in message.txt -out message.rsa

```

这将产生一个名为`message.rsa`的文件，它是二进制格式的。如果我们在 nano 编辑器中打开`message.rsa`，会显示一些垃圾:

![Encryption](Images/image_03_043.jpg)

message.rsa 显示垃圾数据

#### 解密

为了解密 RSA 加密的文件，可以使用以下命令:

```
:~/Crypt$ openssl rsautl -decrypt -inkey privatekey.pem -in message.rsa -out message.dec

```

现在，如果使用 cat 读取文件，可以看到解密的纯文本，如下所示:

```
:~/Crypt$ cat message.dec
datatoencrypt

```

### 使用 OpenSSL 的 ECC

OpenSSL 提供了一个非常丰富的函数库来执行椭圆曲线加密。下一节展示了如何在 OpenSSL 中实际使用 ECC 函数。

#### ECC 私钥和公钥对

在这个例子中，首先给出了一个例子，该例子演示了使用 OpenSSL 库中可用的 ECC 函数来创建私钥。

#### 私钥

ECC 基于由各种标准定义的域参数。我们可以使用以下命令查看 OpenSSL 中所有可用标准定义和推荐的曲线列表:

```
Crypt$ openssl ecparam -list_curves
 secp112r1 : SECG/WTLS curve over a 112 bit prime field
 secp112r2 : SECG curve over a 112 bit prime field
 secp128r1 : SECG curve over a 128 bit prime field
 secp128r2 : SECG curve over a 128 bit prime field
 secp160k1 : SECG curve over a 160 bit prime field
 secp160r1 : SECG curve over a 160 bit prime field
 secp160r2 : SECG/WTLS curve over a 160 bit prime field
 secp192k1 : SECG curve over a 192 bit prime field
 secp224k1 : SECG curve over a 224 bit prime field
 secp224r1 : NIST/SECG curve over a 224 bit prime field
 secp256k1 : SECG curve over a 256 bit prime field
 secp384r1 : NIST/SECG curve over a 384 bit prime field
 secp521r1 : NIST/SECG curve over a 521 bit prime field
 prime192v1: NIST/X9.62/SECG curve over a 192 bit prime field
.
.
.
.
 brainpoolP384r1: RFC 5639 curve over a 384 bit prime field
 brainpoolP384t1: RFC 5639 curve over a 384 bit prime field
 brainpoolP512r1: RFC 5639 curve over a 512 bit prime field
 brainpoolP512t1: RFC 5639 curve over a 512 bit prime field

```

由于这会产生一个很长的输出，因此完整的输出不会显示，并且会在中间被截断。在以下示例中，SECP256k1 用于演示 ECC 的用法。

#### 私钥生成

```
~/Crypt$ openssl ecparam -name secp256k1 -genkey -noout -out ec-privatekey.pem
~/Crypt$ cat ec-privatekey.pem
-----BEGIN EC PRIVATE KEY-----
MHQCAQEEIJHUIm9NZAgfpUrSxUk/iINq1ghM/ewn/RLNreuR52h/oAcGBSuBBAAK
oUQDQgAE0G33mCZ4PKbg5EtwQjk6ucv9Qc9DTr8JdcGXYGxHdzr0Jt1NInaYE0GG
ChFMT5pK+wfvSLkYl5ul0oczwWKjng==
-----END EC PRIVATE KEY-----

```

名为`ec-privatekey.pem`的文件现在包含基于 SECP256K1 曲线生成的 EC 私钥。

为了从私钥生成公钥，发出以下命令:

```
~/Crypt$ openssl ec -in ec-privatekey.pem -pubout -out ec-pubkey.pem
read EC key
writing EC key

```

读取该文件会产生以下输出，显示生成的公钥:

```
~/Crypt$ cat ec-pubkey.pem
-----BEGIN PUBLIC KEY-----
MFYwEAYHKoZIzj0CAQYFK4EEAAoDQgAE0G33mCZ4PKbg5EtwQjk6ucv9Qc9DTr8J
dcGXYGxHdzr0Jt1NInaYE0GGChFMT5pK+wfvSLkYl5ul0oczwWKjng==
-----END PUBLIC KEY-----

```

现在，`ec-pubkey.pem`文件包含了从`ec-privatekey.pem`导出的公钥。

可以使用以下命令进一步研究私钥:

```
~/Crypt$ openssl ec -in ec-privatekey.pem -text -noout
read EC key
Private-Key: (256 bit)
priv:
 00:91:d4:22:6f:4d:64:08:1f:a5:4a:d2:c5:49:3f:
 88:83:6a:d6:08:4c:fd:ec:27:fd:12:cd:ad:eb:91:
 e7:68:7f
pub:
 04:d0:6d:f7:98:26:78:3c:a6:e0:e4:4b:70:42:39:
 3a:b9:cb:fd:41:cf:43:4e:bf:09:75:c1:97:60:6c:
 47:77:3a:f4:26:dd:4d:22:76:98:13:41:86:0a:11:
 4c:4f:9a:4a:fb:07:ef:48:b9:18:97:9b:a5:d2:87:
 33:c1:62:a3:9e
ASN1 OID: secp256k1

```

类似地，可以使用以下命令进一步研究公钥:

```
drequinox@drequinox-OP7010:~/Crypt$ openssl ec -in ec-pubkey.pem -pubin -text -noout
read EC key
Private-Key: (256 bit)
pub:
 04:d0:6d:f7:98:26:78:3c:a6:e0:e4:4b:70:42:39:
 3a:b9:cb:fd:41:cf:43:4e:bf:09:75:c1:97:60:6c:
 47:77:3a:f4:26:dd:4d:22:76:98:13:41:86:0a:11:
 4c:4f:9a:4a:fb:07:ef:48:b9:18:97:9b:a5:d2:87:
 33:c1:62:a3:9e
ASN1 OID: secp256k1
drequinox@drequinox-OP7010:~/Crypt$

```

还可以用所需的参数生成一个文件——在本例中是`SECP256K1`——然后进一步研究它以理解底层参数:

```
~/Crypt$ openssl ecparam -name secp256k1 -out secp256k1.pem
drequinox@drequinox-OP7010:~/Crypt$ cat secp256k1.pem
-----BEGIN EC PARAMETERS-----
BgUrgQQACg==
-----END EC PARAMETERS-----

```

该文件现在包含所有的`SECP256K1`参数，可以使用以下命令进行分析:

```
drequinox@drequinox-OP7010:~/Crypt$ openssl ecparam -in secp256k1.pem -text -param_enc explicit -noout
Field Type: prime-field
Prime:
 00:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:
 ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:fe:ff:
 ff:fc:2f
A:    0
B:    7 (0x7)
Generator (uncompressed):
 04:79:be:66:7e:f9:dc:bb:ac:55:a0:62:95:ce:87:
 0b:07:02:9b:fc:db:2d:ce:28:d9:59:f2:81:5b:16:
 f8:17:98:48:3a:da:77:26:a3:c4:65:5d:a4:fb:fc:
 0e:11:08:a8:fd:17:b4:48:a6:85:54:19:9c:47:d0:
 8f:fb:10:d4:b8
Order:
 00:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:
 ff:fe:ba:ae:dc:e6:af:48:a0:3b:bf:d2:5e:8c:d0:
 36:41:41
Cofactor:  1 (0x1)

```

前面的示例显示了所使用的质数以及`A`和`B`的值，以及`SECP256K1`曲线域参数的生成器、阶数和余因子。

还有另一类加密原语，称为哈希函数。哈希函数不用于加密；数据，而是产生固定长度的文本摘要。

## 密码原语

这种加密原语的分类可以如下图所示:

![Cryptographic primitives](Images/B05975_03_18.jpg)

密码原语

## 哈希函数

散列函数用于创建任意长输入字符串的固定长度摘要。哈希函数是无密钥的，并提供数据完整性服务。它们通常使用迭代和专用散列函数构造技术来构建。有各种散列函数，如 MD、SHA1、SHA-2、SHA-3、RIPEMD 和 Whirlpool。哈希函数常用于数字签名和消息认证码，如 HMACs。它们具有三种安全属性，即抗前像性、抗第二前像性和抗碰撞性。这些属性将在后面的章节中解释。

**哈希函数**通常用于提供数据完整性服务。这些可以用作单向函数，并构造其他加密原语，如 MAC 和数字签名。一些应用程序使用散列函数作为产生**伪随机数** ( **PRNGs** )的手段。哈希函数不需要密钥。根据完整性要求的级别，必须满足散列函数的两个实用属性和三个安全属性。

### 将任意消息压缩成固定长度的摘要

这个属性与这样一个事实有关，即散列函数必须能够接受任意长度的长输入文本，并输出固定长度的压缩消息。散列函数产生各种比特大小的压缩输出，通常在 128 比特和 512 比特之间。

### 易于计算

哈希函数是高效快速的单向函数。要求是无论消息大小如何，它们的计算速度都非常快。如果消息太大，效率可能会降低，但对于实际应用来说，该功能应该足够快。

在下一节中，将讨论哈希函数的安全属性。

### 前像电阻

考虑一个等式:

*h(x) = y*

这里， *h* 是哈希函数， *x* 是输入， *y* 是哈希。第一个安全属性要求 *y* 不能反算为 *x* 。 *x* 被认为是 *y* 的*前像*，因此得名前像电阻。这也叫单向属性。

### 第二个前像电阻

这个性质要求给定 *x* 和 *h(x)* ，几乎不可能找到任何其他消息 *m* ，其中 *m！= x* 和 m 的*哈希= x 的*哈希。 *h(m) = h(x)* 。这种特性也被称为弱抗碰撞性。

### 碰撞阻力

该属性要求两个不同的输入消息不应散列到同一个输出。换句话说， *h(x)！= h(z)* 。这种特性也被称为强抗碰撞性。

哈希函数，由于其本质，总是会有一些冲突，这是两个不同的消息哈希到相同的输出，但它们应该是计算上不可行的。一个被称为**雪崩效应**的概念在所有哈希函数中都是可取的。雪崩效应指定一个小的改变，甚至是输入文本中的单个字符的改变，将导致完全不同的散列输出。

哈希函数通常是按照迭代哈希函数方法设计的。在这种方法中，输入消息在逐块的基础上进行多轮压缩，以产生压缩的输出。一种流行的迭代散列函数是 Merkle-Damgard 构造。这种构造基于将输入数据划分成相等大小的块，然后以迭代的方式通过压缩函数馈送它们的思想。压缩函数的属性的抗冲突性确保散列输出也是抗冲突的。压缩函数可以使用分组密码来构建。除了 Merkle-Damgard，研究人员还提出了其他各种压缩函数的构造，例如 *Miyaguchi-Preneel* 和 *Davies-Meyer* 。

有多种散列函数类别。下一节将向您介绍这些类别。

### 消息摘要(MD)

消息摘要功能在 20 世纪 90 年代早期非常流行。MD4 和 MD5 都属于这一类别。发现两个 MD 函数都不安全，不推荐再使用。MD5 是一种 128 位哈希函数，通常用于文件完整性检查。

### 安全散列算法

SHA-0 :这是 NIST 在 1993 年推出的 160 位函数。

SHA-1:SHA-1 是后来 NIST 引进的，作为 SHA-0 的替代品。这也是一个 160 位的哈希函数。SHA-1 通常用于 SSL 和 TLS 实现中。应该注意的是，SHA-1 现在被认为是不安全的，并被证书颁发机构否决。现在不鼓励在任何新的实现中使用它。 **SHA-2** :这一类包括由 hash 的位数定义的四个函数:SHA-224、SHA-256、SHA-384 和 SHA-512。

**SHA-3** :这是 SHA 函数的最新家族。SHA3-224、SHA3-256、SHA3-384 和 SHA3-512 都是这个家族的成员。SHA3 是 Keccak 的 NIST 标准化版本。凯克使用了一种叫做*海绵构造*的新方法，而不是常用的 Merkle-Damgard 变换。

**RIPEMD** : RIPEMD 是*的缩写*。它基于用于构建 MD4 的设计思想。RIPEMD 有多个版本，包括 128 位、160 位、256 位和 320 位。

**Whirlpool** :这是基于 Rijndael 密码的一个修改版本，称为 w。它使用 Miyaguchi-Preneel 压缩函数，这是一种单向函数，用于将两个固定长度的输入压缩成一个固定长度的输出。这是一个单块长度压缩函数:

![Secure Hash Algorithms (SHAs)](Images/B05975_03_19.jpg)

哈希函数的三个安全属性

哈希函数有许多实际应用，从简单的文件完整性检查和密码存储到用于加密协议和算法。它们用于哈希表、分布式哈希表、bloom 过滤器、病毒指纹、点对点 P2P 文件共享和许多其他应用程序。

在区块链，散列函数起着非常重要的作用。特别是，工作证明函数两次使用 SHA-256 来验证矿工所花费的计算工作量。RIPEMD 160 用于产生比特币地址。这将在后面的章节中详细讨论。

#### 安全哈希算法的设计

在下一节中，将向您介绍 SHA-256 和 SHA-3 的设计。这两者分别用于比特币和以太坊。以太坊没有使用 NIST 标准 SHA-3，而是 Keccak，这是提交给 NIST 的原始算法。NIST，经过一些修改，如增加轮数和更简单的消息填充，将 Keccak 标准化为 SHA-3。

#### SHA-256

SHA-256 的输入消息大小< 2^64-bits.块大小为 512 位，字长为 32 位。输出是 256 位摘要。

压缩功能处理 512 位消息块和 256 位中间哈希值。该功能有两个主要组成部分:压缩功能和消息调度。

该算法的工作原理如下:

*   预处理:
    1.  消息的填充，用于在块的长度小于所需的 512 位块大小时，使块的长度达到 512 位。
    2.  将消息解析成消息块，以确保消息及其填充被分成相等的 512 位块。
    3.  设置初始散列值，它是通过取前八个素数的平方根的小数部分的前 32 位获得的八个 32 位字。这些初始值是随机选择的，以便初始化该过程，并给出算法中不存在后门的置信度。
*   哈希计算:
    1.  每个消息块按顺序处理，需要 64 轮来计算完整的哈希输出。每一轮使用稍微不同的常数，以确保没有两轮是相同的。
    2.  首先，准备消息时间表。
    3.  然后，初始化八个工作变量。
    4.  然后，计算中间哈希值。
    5.  Finally, the message is processed and the output hash is produced:

        ![SHA-256](Images/B05975_03_20.jpg)

        一轮 SHA 256 压缩功能

在上图中， *a* ， *b* ， *c* ， *d* ， *e* ， *f* ， *g* ， *h* 为寄存器。 **Maj** 和 **Ch** 按位应用。![SHA-256](Images/image_03_048.jpg)执行逐位旋转。轮常数为**w<sub class="calibre61">j</sub>t24】和**k<sub class="calibre61">j</sub>t28】，增加了 *mod 2^32* 。****

#### SHA3 的设计(Keccak)

沙-3 的结构与通常的 SHA-1 和 SHA-2 非常不同。SHA-3 背后的关键思想是基于无密钥排列，而不是使用密钥排列的其他常见散列函数构造。Keccak 也没有利用 Merkle-Damgard 转换，这种转换通常用于在散列函数中处理任意长度的输入消息。Keccak 使用了一种更新的方法，称为海绵和挤压构造，这基本上是一种随机排列模型。SHA3 的不同变体已经被标准化，例如 SHA3-224、SHA3-256、SHA3-384、SHA3-512、SHAKE128 和 SHAKE256。SHAKE128 和 SHAKE256 是可扩展的输出函数，也由允许输出扩展到任何期望长度的`NIST.XOF`函数标准化。

下图显示了作为 SHA3 或 Keccak 基础的海绵和挤压模型。与海绵类似，首先，在应用填充后，数据被吸收到海绵中，然后使用 XOR 将其变为置换状态的子集，然后从表示转换状态的海绵函数中挤出输出。Rate 是海绵函数的输入块大小，而 capacity 决定通用安全级别:

![Design of SHA3 (Keccak)](Images/B05975_03_21.jpg)

SHA3 中的 SHA-3 吸收和挤压功能

#### OpenSSL 散列函数的例子

以下命令将使用 SHA256 算法生成 256 位 Hello 消息的哈希:

```
:~/Crypt$ echo -n 'Hello' | openssl dgst -sha256
(stdin)= 185f8db32271fe25f561a6fc938b2e264306ec304eda518007d1764826381969

```

注意，即使是文本中很小的变化，比如改变 *H* 的大小写，也会导致输出散列值的很大变化。这被称为*雪崩效应*，如前所述:

```
:~/Crypt$ echo -n 'hello' | openssl dgst -sha256
(stdin)= 2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824

```

请注意，两种输出完全不同:

```
Hello: 18:5f:8d:b3:22:71:fe:25:f5:61:a6:fc:93:8b:2e:26:43:06:ec:30:4e:da:51:80:07:d1:76:48:26:38:19:69
hello: 2c:f2:4d:ba:5f:b0:a3:0e:26:e8:3b:2a:c5:b9:e2:9e:1b:16:1e:5c:1f:a7:42:5e:73:04:33:62:93:8b:98:24

```

#### 消息认证码(MAC)

MAC 有时被称为键控散列函数，可用于提供消息完整性和认证。换句话说，它们用于提供数据源认证。这些是对称加密原语，使用发送方和接收方之间的共享密钥。MAC 可以使用分组密码或散列函数来构造。

#### 使用分组密码的 MAC

在这种方法中，在**密码块链接模式** ( **CBC 模式**)中使用块密码，以便生成 MAC。可以使用任何分组密码，例如 CBC 模式下的 AES。消息的 MAC 实际上是最后一轮 CBC 操作的输出。MAC 输出的长度与用于生成 MAC 的分组密码的分组长度相同。通过计算消息的 MAC 并将其与接收到的 MAC 进行比较，可以简单地验证 MAC。如果它们相同，则确认消息完整性；否则，该消息被视为已被更改。还应该注意，MAC 的工作方式类似于数字签名，但是由于它们的对称特性，它们不能提供认可服务。

#### 基于散列的 MAC

与哈希函数类似，它们产生固定长度的输出，并接受任意长的消息作为输入。在该方案中，发送方使用 MAC 对消息进行签名，接收方使用共享密钥对其进行验证。使用两种方法(称为“秘密前缀”或“秘密后缀”方法)之一将密钥与消息进行哈希处理。在第一种方法中，密钥与消息连接在一起，即密钥在前，消息在后，而在后一种方法中，密钥在消息之后:

*秘密前缀:M = MACk(x) = h(k||x)*

*秘密后缀:M=MACk(x) = h(x||k)*

这两种方法各有利弊。已经发现了对这两种方案的一些攻击。有一些 HMAC 构建方案使用了各种技术，如研究人员提出的 **ipad** 和 **opad** (内部填充和外部填充)，这些方案在一些假设下被认为是安全的:

![HMACs (hash-based MACs)](Images/B05975_03_22.jpg)

MAC 功能的操作

### Merkle 树

Merkle 树的概念是由 Ralph Merkle 提出的。这里展示了 Merkle 树的可视化，这使得它很容易理解。Merkle 树允许对大型数据集进行安全有效的验证。

它是一个二叉树，首先将输入放在叶子上(没有子节点的节点)，然后将子节点对的值散列在一起，以产生父节点(内部节点)的值，直到获得称为 Merkle root 的单个散列值:

![Merkle trees](Images/B05975_03_23.jpg)

Merkle 树

### 帕特丽夏树

为了理解 Patricia trees，首先，你将被介绍到一个 **trie** 的概念。trie 或数字树是用于存储数据集的有序树数据结构。

**检索以字母数字编码的信息的实用算法** ( **帕特里夏**)，也称为基数树，是一种 trie 的紧凑表示，其中作为父节点的唯一子节点与其父节点合并。

**Merkle-Patricia tree** ，基于 Patricia 和 Merkle 的定义，是一种具有包含整个数据结构的哈希值的根节点的树。

### 分布式哈希表

哈希表是一种用于将键映射到值的数据结构。在内部，哈希函数用于计算桶数组的索引，从中可以找到所需的值。存储桶使用哈希键存储记录，并按照特定的顺序组织。

记住前面提供的定义，我们可以将分布式哈希表视为一种数据结构，其中数据分布在各个节点上，节点相当于对等网络中的存储桶。

下图直观地显示了 DHT 是如何工作的。该示例显示数据通过哈希函数传递，这导致生成一个紧凑的密钥。然后，该密钥与对等网络上的数据(值)相链接。当网络上的用户请求数据(通过文件名)时，可以再次散列文件名以产生相同的密钥，然后可以请求网络上的任何节点找到相应的数据。DHTs 提供了去中心化、容错和可伸缩性:

![Distributed hash tables (DHTs)](Images/B05975_03_24.jpg)

分布式哈希表

### 数字签名

数字签名提供了一种将消息与发出该消息的实体相关联的方法。数字签名用于提供数据源认证和不可否认性。它们分两步计算。RSA 数字签名方案的高级步骤如下所示:

1.  计算数据包的哈希值。这将提供数据完整性保证，因为可以在接收端再次计算散列，并将其与原始散列进行匹配，以检查数据是否在传输过程中被修改。从技术上讲，消息签名可以在不首先散列数据的情况下工作，但是不被认为是安全的。
2.  第二步用签名者的私钥对哈希值进行签名。由于只有歌手拥有私钥，签名和签名数据的真实性得到了保证。

数字签名有一些重要的属性，如真实性、不可伪造性和不可重用性。真实性意味着数字签名可被接收方验证。不可伪造性属性确保只有消息的发送方能够使用私钥来使用签名功能。换句话说，其他任何人都不能生成由合法发送者生成的签名消息。不可重用性是指数字签名不能从一条消息中分离出来并再次用于另一条消息。

下图显示了通用数字签名功能的操作:

![Digital signatures](Images/B05975_03_25.jpg)

数字签名(左)和验证过程(右)(RSA 数字签名示例)

如果发送方想要向接收方发送经过身份验证的消息，有两种方法可以使用。这里介绍了使用加密数字签名的两种方法。

#### 签名然后加密

在这种方法中，发送方使用私钥对数据进行数字签名，将签名附加到数据中，然后使用接收方的公钥对数据和数字签名进行加密。与下面描述的先加密后签名方案相比，这被认为是更安全的方案。

#### 加密然后签名

在这种方法中，发送方使用接收方的公钥加密数据，然后对加密的数据进行数字签名。

### 注意

实际上，包含数字签名的数字证书是由一个**认证机构** ( **CA** )发布的，它将一个公钥与一个身份相关联。

各种方案，例如 RSA、数字签名算法和基于椭圆曲线数字签名算法的数字签名方案在实践中被使用。RSA 是最常用的；然而，随着椭圆曲线密码技术的发展，基于 ECDSA 的方案也变得非常流行。

这里详细描述 ECDSA 方案。

## 椭圆曲线数字签名算法(ECDSA)

为了使用 ECDSA 方案进行签名和验证，需要生成第一个密钥对:

1.  首先定义一条椭圆曲线 *E* :
    1.  同模数 *P* 。
    2.  系数 *a* 和 *b* 。
    3.  生成点 *A* 形成素数阶的循环群 *q.*
2.  随机选择一个整数 *d* ，使得 *0 < d < q* 。
3.  计算公钥 *B* 使得 *B = d A.*

公钥是如下所示形式的六元组:

Kpb = (p，A，B，q，A，B)

在步骤 2 中随机选择私钥 *d* :

kpresenter = d

现在可以使用私钥和公钥生成签名。

1.  首先，选择一个短暂密钥 *Ke* ，其中 *0 < Ke < q* 。要保证 *Ke* 是真正随机的，没有两个签名是同一个密钥；否则，可以计算私钥。
2.  另一个值 *R* 是使用 *R = Ke A* 计算的，即通过将 *A* (生成点)与随机短暂密钥相乘。
3.  用点 *R* 的 *x* 坐标值初始化变量 *r* 。 *r = xR。*
4.  The signature can be calculated as follows:

    ![Elliptic Curve Digital signature algorithm (ECDSA)](Images/B05975_02-1.jpg)

这里， *m* 是正在计算签名的消息，而 *h(m)* 是消息 *m* 的散列。

签名验证按照以下过程进行。

1.  辅助值 w 计算为 *w = s <sup class="calibre44">-1</sup> mod q* 。
2.  辅助值 *u1 = w. h(m) mod q.*
3.  辅助值 *u2 = w. r mod q* 。
4.  计算点 *P* ， *P = u1A + u2B。*
5.  验证按如下方式进行。
6.  *r*, *s* is accepted as a valid signature if x-coordinate of the point *P* calculated in Step 4 has the same value as the signature parameter *r mod q*.

    那就是:

    *Xp = r mod q 表示有效签名*

    *Xp！= r mod q 表示无效签名*

这里展示了各种实际例子，展示了如何使用 OpenSSL 生成、使用和验证 RSA 数字签名。

### 如何生成数字签名

第一步是生成消息文件的散列:

```
:~/Crypt$ openssl dgst -sha256 message.txt
SHA256(message.txt)= eb96d1f89812bf4967d9fb4ead128c3b787272b7be21dd2529278db1128d559c

```

哈希生成和签名都可以在一个步骤中完成，如此处所示。注意`privatekey.pem`是在前面提供的步骤中生成的:

```
:~/Crypt$ openssl dgst -sha256 -sign privatekey.pem -out signature.bin message.txt

```

现在让我们显示显示相关文件的目录:

```
:~/Crypt$ ls -ltr
total 36
-rw-rw-r-- 1 drequinox drequinox  14 Sep 21 05:54 message.txt
-rw-rw-r-- 1 drequinox drequinox  32 Sep 21 05:57 message.bin
-rw-rw-r-- 1 drequinox drequinox  45 Sep 21 06:00 message.b64
-rw-rw-r-- 1 drequinox drequinox  32 Sep 21 06:16 message.ptx
-rw-rw-r-- 1 drequinox drequinox 916 Sep 21 06:28 privatekey.pem
-rw-rw-r-- 1 drequinox drequinox 272 Sep 21 06:30 publickey.pem
-rw-rw-r-- 1 drequinox drequinox 128 Sep 21 06:43 message.rsa
-rw-rw-r-- 1 drequinox drequinox  14 Sep 21 06:49 message.dec
-rw-rw-r-- 1 drequinox drequinox 128 Sep 21 07:05 signature.bin
:~/Crypt$ cat signature.bin

```

![How to generate a digital signature](Images/B05975_03_55.png)

为了验证签名，可以执行以下操作:

```
:~/Crypt$ openssl dgst -sha256 -verify publickey.pem -signature signature.bin message.txt
Verified OK
:~/Crypt$

```

同样，如果使用了其他无效的签名文件，验证将会失败，如下所示:

```
:~/Crypt$ openssl dgst -sha256 -verify publickey.pem -signature someothersignature.bin message.txt
Verification Failure

```

现在将向您介绍一个示例，展示如何使用 OpenSSL 来执行与 ECDSA 相关的操作。

### 使用 OpenSSL 的 ECDSA

首先，使用以下命令生成私钥:

```
~/Crypt$ openssl ecparam -genkey -name secp256k1 -noout -out eccprivatekey.pem 
~/Crypt$ cat eccprivatekey.pem
-----BEGIN EC PRIVATE KEY-----
MHQCAQEEIMVmyrnEDOs7SYxS/AbXoIwqZqJ+gND9Z2/nQyzcpaPBoAcGBSuBBAAK
oUQDQgAEEKKS4E4+TATIeBX8o2J6PxKkjcoWrXPwNRo/k4Y/CZA4pXvlyTgH5LYm
QbU0qUtPM7dAEzOsaoXmetqB+6cM+Q==
-----END EC PRIVATE KEY-----

```

现在公钥是由私钥生成的:

```
~/Crypt$ openssl ec -in eccprivatekey.pem -pubout -out eccpublickey.pem
read EC key
writing EC key
~/Crypt$ cat eccpublickey.pem
-----BEGIN PUBLIC KEY-----
MFYwEAYHKoZIzj0CAQYFK4EEAAoDQgAEEKKS4E4+TATIeBX8o2J6PxKkjcoWrXPw
NRo/k4Y/CZA4pXvlyTgH5LYmQbU0qUtPM7dAEzOsaoXmetqB+6cM+Q==
-----END PUBLIC KEY-----
~/Crypt$

```

现在假设一个名为`testsign.txt`的文件需要签名和验证。这可以通过以下方式实现:

1.  创建一个测试文件:

    ```
    ~/Crypt$ echo testing > testsign.txt
    ~/Crypt$ cat testsign.txt
    testing

    ```

2.  运行以下命令，使用私钥为`testsign.txt`文件生成签名:

    ```
    ~/Crypt$ openssl dgst -ecdsa-with-SHA1 -sign eccprivatekey.pem     
            testsign.txt > ecsign.bin

    ```

3.  最后，验证命令可以如下所示运行:

    ```
    ~/Crypt$ openssl dgst -ecdsa-with-SHA1 -verify eccpublickey.pem   
            -signature ecsign.bin testsign.txt
    Verified OK

    ```

也可以使用之前生成的私钥生成证书:

```
~/Crypt$ openssl req -new -key eccprivatekey.pem -x509 -nodes -days 365 -out ecccertificate.pem
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [AU]:GB
State or Province Name (full name) [Some-State]:Cambridge
Locality Name (eg, city) []:Cambridge
Organization Name (eg, company) [Internet Widgits Pty Ltd]:Dr.Equinox!
Organizational Unit Name (eg, section) []:NA
Common Name (e.g. server FQDN or YOUR name) []:drequinox
Email Address []:drequinox@drequinox.com

```

可以使用下面的命令浏览该证书:

```
~/Crypt$ openssl x509 -in ecccertificate.pem -text -noout

```

![ECDSA using OpenSSL](Images/image_03_057.jpg)

使用 ECDSA 算法和 SHA-256 的 X509 证书

由于与区块链的相关性或在未来区块链生态系统中的潜在用途，这里还介绍了密码学中的其他主题。

### 同态加密

通常公钥密码体制如 RSA 是乘法同态或加法同态，如 Paillier 密码体制，称为**部分同态**系统。附加 phe 适用于电子投票和银行应用。直到最近，还没有支持这两种操作的系统，但是在 2009 年， *Craig Gentry* 发现了一个**全同态**系统。由于这些方案允许在不需要解密的情况下处理加密数据，因此它们具有许多不同的可能应用，特别是在需要维护隐私但数据也需要由潜在的不可信方处理的情况下，例如云计算和在线搜索引擎。同态加密的最新发展非常有前途，研究人员正在积极努力使其更有效和更实用。正如本书后面所描述的，这是区块链技术中特别令人感兴趣的，因为它可以解决区块链的保密性和隐私性问题。

### 签密

签密是一种公钥加密原语，提供数字签名和加密的所有功能。它是由*郑玉良*发明的，现在是 ISO 标准 ISO/IEC 29150:2011。传统上，先签名后加密或先加密后签名方案用于提供不可伪造性、认证和不可否认性，但使用签密，所有数字签名和加密服务的成本都低于先签名后加密方案。

这就是**成本(签名&加密)< <成本(签名)+成本(加密)**在一个单一的逻辑步骤中。

### 零知识证明

零知识证明由*戈德瓦瑟*、*米卡里*、*拉科夫*介绍。这些证明用于证明一个断言的有效性，而不会透露关于该断言的任何信息。ZKPs 需要三个性质，即完备性、可靠性和零知识性质。

完整性确保了如果某个断言为真，那么验证者将被证明者说服。可靠性属性确保如果断言是假的，那么没有不诚实的证明者能够说服验证者。顾名思义，零知识性质是零知识证明的关键性质，由此确保除了断言是真还是假之外，绝对没有任何关于断言的内容被揭示。

零知识证明在区块链空间引起了研究人员的特别兴趣，因为它的隐私属性在金融和许多其他领域，如法律和医学中非常理想。最近成功实现零知识证明机制的一个例子是 Zcash 加密货币。在 Zcash 中，实现了一种特定类型的零知识证明，称为**零知识简洁的非交互式知识论证**(**ZK-斯纳克**)。这个会在[第五章](05.html "Chapter 5. Alternative Coins")、*备选币*中详细讨论。

### 盲签名

盲签名是由 David Chaum 于 1982 年提出的，它基于公钥数字签名方案，如 RSA。盲签名背后的关键思想是让签名者对消息进行签名，而不实际暴露消息。这是通过在签名前伪装或隐藏消息来实现的，因此称为盲签名。然后，可以像普通的数字签名一样，对照原始消息来验证该盲签名。盲签名作为一种机制被引入，以允许数字现金方案的发展。

### 编码方案

除了密码原语，二进制到文本的编码方案也用于各种场景。最常见的用法是将二进制数据转换为文本，以便可以通过不支持二进制数据处理的协议对其进行处理、保存或传输。例如，有时，图像以 base64 编码存储在数据库中，这允许文本字段能够存储图片。一种常用的编码方案是 base64。另一种名为 base58 的编码因其在比特币中的使用而流行起来。

密码学是一个广阔的领域，本节介绍了从总体上理解密码学，特别是从区块链和加密货币的角度理解密码学所必需的基本概念。在下一节中，您将了解基本的金融市场概念。

接下来的部分描述了关于交易、交换和交易生命周期的一般术语。更多相关信息将在后面讨论具体用例的章节中提供。

# 金融市场和交易

金融市场的存在是为了促进储蓄从储户向投资者的转移。在一个经济体系中，有两个部门，即家庭和企业。金融市场的核心是充当储户和投资者之间的中介。基本上，有三种类型的市场，即货币市场，信贷市场和资本市场。货币市场是短期市场，资金借出给公司或银行进行银行间借贷。外汇或 FX 是货币交易的另一类货币市场。信贷市场主要由零售银行组成，它们从中央银行借钱，并以抵押或贷款的形式借给公司或家庭。

资本市场促进金融工具的买卖，主要是股票和债券。资本市场可以分为两种，一级市场和二级市场。公司在一级市场直接向投资者发行股票，而在二级市场，投资者通过证券交易所向投资者转售证券。交易所使用各种电子交易系统来促进金融工具的交易。

## 交易

市场是商人来交易的地方。它可以输入资产类别。

交易可以定义为交易者买卖各种金融工具以产生利润和对冲风险的活动。投资者、借款者、对冲者、资产交换者和赌徒是交易者的几种类型。当交易者欠某样东西时，他们有一个空头头寸，例如，如果他们已经卖出了一份合约，而当他们买入一份合约时，他们有一个多头头寸。交易有多种方式，如通过经纪人或直接在交易所或柜台交易。经纪人是为客户安排交易的代理人。经纪人代表客户以给定的价格或尽可能好的价格进行交易。

## 交流

交易所通常被认为是一个非常安全、规范和可靠的交易场所。最近，与传统的场内交易相比，电子交易获得了高度的普及。现在，交易者将订单发送到中央电子订单簿，订单、价格和相关属性通过通信网络从该电子订单簿发布到所有相关联的系统，因此实质上创建了虚拟市场。交易所交易只能由交易所会员进行。为了不受这些限制进行交易，交易对手可以直接参与**OTC**(**Over the Counter**)交易。

### 订单和订单属性

订单是交易的指令，是交易系统的主要组成部分。它们具有以下一般属性:

1.  乐器名称。
2.  数量。
3.  方向(买入或卖出)。
4.  代表各种条件的订单类型，例如限价订单和止损订单，例如 15.50 英镑的 1500 股苏格兰皇家银行普通股。

订单根据买入价和卖出价进行交易。交易者通过在订单上附上买价和卖价来表明他们的买卖意图。交易者买入的价格称为买入价。交易者愿意卖出的价格被称为出价。

### 订单管理和路线系统

订单路由系统根据业务逻辑将订单路由和交付到不同的目的地。客户用它们向经纪人发送订单，经纪人再将这些订单发送给交易商、清算所和交易所。

订单有不同的类型；最常见的两种是市价订单和限价订单。市价单是以市场上当前可获得的最佳价格进行交易的指令，这些订单会立即以现货价格成交。另一方面，限价单是一种以最佳价格交易的指令，但前提是该价格不低于交易者设定的限价。这也可以更高，取决于订单的方向，要么卖出，要么买入。所有这些订单都在订单簿中管理，订单簿是由交易所维护的订单列表，记录交易者的购买或出售意图。

头寸是以给定价格卖出或买入一定数量的金融工具，如证券、货币或商品的承诺。交易员买卖的合约、证券、商品和货币通常被称为交易工具，属于资产类别的大范畴。最常见的类别是实物资产、金融资产、衍生合同和保险合同。

### 交易的组成部分

交易单是与交易相关的所有细节的组合。然而，根据工具类型和资产类别的不同，会有一些差异，但一般来说，所有工具都具有下一节讨论的属性。

### 注意

**底层工具**

基础工具是交易的基础。它可以是货币、债券、利率、商品或股票。

### 一般属性

这包括与每笔交易相关的一般识别信息和基本特征。常见属性包括唯一 ID、工具名称、类型、状态、交易日期和时间。

### 经济

这些是与交易价值相关的特性，例如，买入或卖出价值、报价器、汇率、价格和数量。

### 销售

销售是指与销售特征相关的详细信息，如销售人员的姓名，它只是一个信息字段，通常对贸易生命周期没有任何影响。

### 交易对手

交易对手是交易的一个重要组成部分，因为它显示了交易的另一面，是成功结算交易所必需的。通常的属性包括交易对手名称、地址、付款类型、任何参考 id、结算日期和交付类型。

## 贸易生命周期

一般的交易生命周期包括从下单到执行再到结算的各个阶段。这个生命周期按步骤描述如下:

*   **预执行**:此阶段下单。
*   **执行与预订**:订单撮合执行后，转换为交易。在这个阶段，交易对手之间的合同已经到期。
*   **确认**:这是交易双方同意交易细节的地方。
*   **登记后**:该阶段涉及各种审查和验证过程，以确定交易的正确性。
*   **结算**:这是交易过程中最重要的部分，在这个阶段，交易是最终的。
*   **隔夜(日终处理)**:日终处理包括报表生成、损益计算和各种风险计算。
*   在所有提到的过程中，涉及到许多人和业务职能。最常见的是，这些功能分为前台、中台和后台等功能。

在下一节中，您将了解一些基本概念，以便理解管理金融行业的严格且必要的规则和条例。这里描述了一些概念，在后面的章节中讨论具体的用例时，这些概念将帮助您理解所描述的场景。

## 订单预期者

订单预期者试图在其他交易者进行交易之前获利。这是基于交易者知道其他交易的交易活动将如何影响价格的预期。领跑者、情绪导向的技术交易者和挤压者都是订单预期者的例子。

## 市场操纵

在英国和其他国家，市场操纵绝对是非法的。欺诈交易者可以在市场上散布虚假信息，导致价格波动，从而非法获利。通常，操纵市场行为是基于交易的，它包括一般的和特定时间的操纵。这类行为可能造成人为的库存短缺、虚假活动的印象以及操纵价格以获取犯罪利益。

前面讨论的两个术语都与金融犯罪有关。并且有可能开发基于区块链的系统来阻止市场滥用。这将在后面的章节中详细讨论，其中将讨论具体的用例。

# 总结

本章旨在介绍密码学和金融市场的概念，为你理解后面章节的内容提供背景信息。首先，向您介绍了密码学的基础知识，然后介绍了对称和非对称密码等各种方案。展示了使用 OpenSSL 命令行的实际例子，以便您可以试验各种命令并亲身体验各种加密功能。此外，在本章的开始和必要的地方提供了一些数学背景，特别是椭圆曲线加密。本章中介绍的所有加密概念都与区块链技术相关，并已在各种区块链、加密货币和相关生态系统中实现或已被提议实现。此外，您还快速了解了金融行业，因为它为各种示例奠定了基础，这些示例将在本书后面的分布式分类帐技术中讨论。由于密码学和金融是一个庞大的主题，本章所涵盖的内容本质上是介绍性的(有一些例外)，具体的主题将在接下来的章节中根据需要进行更详细的阐述。