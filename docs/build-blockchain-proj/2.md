# 了解以太坊的工作原理

在前一章中，我们看到了 DApps 是什么。我们还看到了一些流行的 DApps 的概述。其中之一是以太坊。目前，以太坊是继比特币之后最受欢迎的 DApp。在这一章中，我们将深入了解以太坊是如何工作的，以及我们可以使用以太坊开发什么。我们还将看到重要的以太坊客户端和节点实现。

在本章中，我们将讨论以下主题:

*   以太坊用户账户
*   什么是智能合约，它们是如何工作的？
*   以太坊虚拟机
*   挖掘在工作证明共识协议中是如何工作的？
*   学习如何使用 geth 命令
*   设置以太坊钱包和薄雾
*   耳语和蜂群概述
*   以太坊的未来

# 以太坊概述

以太坊是一个去中心化的平台，允许我们在其上部署 DApps。智能合同是使用 solidity 编程语言编写的。DApps 是使用一个或多个智能合约创建的。智能合同是完全按照程序运行的程序，没有任何停机、审查、欺诈或第三方接口的可能性。在以太坊中，智能合约可以用几种编程语言编写，包括 Solidity、LLL 和 Serpent。Solidity 是这些语言中最受欢迎的。以太坊有一种内部货币叫做以太。要部署智能契约或调用它们的方法，我们需要以太。与任何其他 DApp 一样，智能合约可以有多个实例，每个实例都由其唯一的地址来标识。用户帐户和智能合约都可以持有以太网。

以太坊使用区块链数据结构和工作证明一致协议。智能合约的方法可以通过事务或其他方法调用。网络中有两种节点:常规节点和矿工节点。常规节点是那些只有区块链副本的节点，而矿工通过挖掘区块来构建区块链。

# 以太坊账户

要创建一个以太坊账户，我们只需要一个非对称密钥对。生成非对称加密密钥有各种算法，如 RSA、ECC 等。以太坊使用**椭圆曲线密码** ( **ECC** )。ECC 有各种参数。这些参数用于调整速度和安全性。以太坊使用`secp256k1`参数。深入了解 ECC 及其参数需要数学知识，使用以太坊构建 DApps 不需要深入了解。

以太坊使用 256 位加密。以太坊私钥/公钥是一个 256 位的数字。由于处理器不能表示这么大的数字，它被编码为长度为 64 的十六进制字符串。

每个账户都由一个地址代表。一旦我们有了生成地址所需的密钥，下面是从公钥生成地址的过程:

1.  首先，生成公钥的`keccak-256`散列。它会给你一个 256 位的数字。
2.  丢弃前 96 位，即 12 个字节。您现在应该有 160 位二进制数据，即 20 个字节。
3.  现在将地址编码为十六进制字符串。所以最后，你会有一个 40 个字符的字节，这是你的帐户地址。

现在任何人都可以把乙醚送到这个地址。

# 处理

**事务**是一个已签名的数据包，用于将以太网从一个帐户转移到另一个帐户或合同，调用合同的方法，或部署新合同。使用 **ECDSA** ( **椭圆曲线数字签名算法**)对交易进行签名，这是一种基于 ECC 的数字签名算法。交易包含消息的接收者、标识发送者并证明其意图的签名、要传输的乙醚量、允许交易执行的最大计算步骤数(称为气价限制)以及交易的发送者愿意为每个计算步骤支付的成本(称为气价)。如果事务的目的是调用契约的方法，它也包含输入数据，或者如果它的目的是部署契约，那么它可以包含初始化代码。用气量和气价的乘积称为交易费用。要发送以太网或执行合同方法，您需要向网络广播事务。发送者需要用其私钥对交易进行签名。

如果我们确信一个交易将总是出现在区块链，那么这个交易就被认为是被确认的。建议等待 15 次确认，然后再假设交易需要确认。

# 共识；一致

以太坊网络中的每个节点都有一份区块链的拷贝。我们需要确保节点不能篡改区块链，我们还需要一种机制来检查块是否有效。此外，如果我们遇到两个不同的有效区块链，我们需要有一种方法来找出选择哪一个。

以太坊使用工作证明共识协议来防止区块链被篡改。工作验证系统包括解决一个复杂的难题来创造一个新的积木。解决这个难题需要大量的计算能力，因此很难创建块。在工作证明系统中创建块的过程称为挖掘。矿工是网络中开采区块的节点。所有使用工作证明的 DApps 并不实现完全相同的算法集。它们可能在谜题挖掘者需要解决什么，谜题有多难，解决它需要多少时间等等方面有所不同。我们将学习有关以太坊的工作证明。

任何人都可以成为网络中的矿工。每个矿工单独解决难题；第一个解决难题的矿工是赢家，并获得该区块所有交易的五个以太和交易费的奖励。如果你有一个比网络中任何其他节点都更强大的处理器，这并不意味着你总是会成功，因为对于所有的矿工来说，谜题的参数并不完全相同。但是，如果你有一个比网络中任何其他节点都更强大的处理器，它会给你更大的成功机会。工作证明的行为就像一个彩票系统，处理能力可以被认为是一个人拥有的彩票数量。网络安全不是用矿工总数来衡量的；相反，它是由网络的总处理能力来衡量的。

区块链能拥有的块数没有限制，能产生的以太总量也没有限制。一旦一个挖掘器成功地挖掘了一个块，它就将该块广播给网络中的所有其他节点。一个块有一个标题和一组事务。每个块保存前一个块的散列，从而创建一个连接链。

让我们看看矿工需要解决的难题是什么，以及如何在高层次上解决它。要挖掘一个块，首先，挖掘器收集广播给它的新的未挖掘的事务，然后过滤掉无效的事务。有效的交易必须使用私钥正确签名，帐户必须有足够的余额来进行交易，等等。现在矿工创建了一个块，它有一个头和内容。内容是块包含的事务列表。头包含诸如前一个块的散列、块号、nonce、目标、时间戳、难度、矿工的地址等等。时间戳表示块开始的时间。那么 nonce 就是一个无意义的值，调整它是为了找到谜题的解。难题基本上是找到这样的 nonce 值，当块被散列时，散列值小于或等于目标值。以太坊使用 ethash 哈希算法。找到随机数的唯一方法是枚举所有的可能性。目标是一个 256 位的数字，它是根据各种因素计算出来的。标题中的难度值是目标的一种不同的表示，使它更容易处理。目标越低，查找 nonce 所需的时间越多，目标越高，查找 nonce 所需的时间越少。下面是计算拼图难度的公式:

```
current_block_difficulty = previous_block_difficulty + previous_block_difficulty // 2048 * max(1 - (current_block_timestamp - previous_blocktimestamp) // 10, -99) + int(2 ** ((current_block_number // 100000) - 2)) 

```

现在，网络中的任何节点都可以通过首先检查区块链中的事务是否有效、时间戳验证，然后检查所有块的目标和随机数是否有效、矿工本身是否分配了有效的奖励等等，来检查他们拥有的区块链是否有效。

如果网络中的一个节点接收到两个不同的有效区块链，那么所有块的组合难度较高的区块链被认为是有效区块链。

现在，例如，如果网络中的一个节点改变了一个块中的一些事务，那么该节点需要计算所有后续块的随机数。当它重新发现后续块的随机数时，网络将会挖掘更多的块，因此拒绝这个区块链，因为它的组合难度将会更低。

# 时间戳

计算数据块目标的公式需要当前时间戳，而且每个数据块的头上都附有当前时间戳。在挖掘新的块时，没有什么可以阻止挖掘器使用其他时间戳而不是当前时间戳，但他们通常不会，因为时间戳验证会失败，其他节点不会接受该块，这将浪费挖掘器的资源。当挖掘器广播新挖掘的块时，通过检查时间戳是否大于前一个块的时间戳来验证其时间戳。如果矿工使用比当前时间戳更大的时间戳，则难度将会较低，因为难度与当前时间戳成反比；因此，其块时间戳是当前时间戳的挖掘器将被网络接受，因为它将具有更高的难度。如果挖掘者使用大于先前块时间戳且小于当前时间戳的时间戳，则难度会更高，因此，挖掘块会花费更多时间；到该块被开采时，网络已经生产了更多的块，因此，该块将被拒绝，因为恶意开采者的区块链将比网络的区块链具有更低的难度。由于这些原因，矿工总是使用准确的时间戳，否则他们一无所获。

# 目前

nonce 是一个 64 位无符号整数。随机数是这个谜题的答案。挖掘器不断增加 nonce，直到找到解决方案。现在你一定在想，如果有一个挖掘者比网络中的其他挖掘者拥有更大的散列能力，那么这个挖掘者会总是首先找到 nonce 吗？不会的。

矿工正在开采的块的散列对于每个矿工来说都是不同的，因为散列取决于诸如时间戳、矿工地址等等之类的东西，并且它不太可能对于所有矿工都是相同的。因此，这不是一场解谜比赛；相反，这是一个彩票系统。但是当然，一个矿工很可能会幸运，这取决于它的散列能力，但这并不意味着矿工总能找到下一个块。

# 封锁时间

我们之前看到的方块难度公式使用了一个 10 秒的阈值来确保父方块和子方块的时间差在 10-20 秒之间。但是为什么是 10-20 秒而不是其他值呢？为什么会有恒定的时差限制而不是恒定的难度？

想象一下，我们有一个恒定的难度，矿工只需要找到一个 nonce 就可以得到这个块的 hash 小于等于这个难度。假设难度高；那么在这种情况下，用户将没有办法知道将以太发送给另一个用户需要多长时间。如果网络的计算能力不足以快速找到随机数来满足困难，则可能需要很长时间。有时，网络可能会很幸运，很快找到随机数。但这种系统很难吸引用户，因为用户总是想知道完成一笔交易需要多长时间，就像当我们把钱从一个银行账户转到另一个银行账户时，我们有一个完成交易的时间段。如果恒定难度较低，将损害区块链的安全，因为大型矿工可以比小型矿工更快地开采区块，网络中最大的矿工将有能力控制 DApp。因为网络的计算能力不是恒定的，所以不可能找到一个恒定的能使网络稳定的难度值。

现在我们知道了为什么我们总是应该有一个网络挖掘一个块的平均时间。现在的问题是什么是最合适的平均时间，因为它可以是从 1 秒到无限秒的任何时间。降低难度可以获得更小的平均时间，增加难度可以获得更高的平均时间。但是更低和更高的平均时间有什么优点和缺点呢？在我们讨论这个问题之前，我们需要首先知道什么是陈旧块。

如果两个矿工几乎同时开采下一个区块会发生什么？两个区块肯定都有效，但是区块链不能拥有两个相同区块编号的区块，而且两个矿工也不能被奖励。虽然这是一个常见问题，但解决方案很简单。最终，难度较高的区块链将会被网络接受。所以最终被遗漏的有效块被称为陈旧块。

网络中产生的旧块总数与生成一个新块的平均时间成反比。更短的块生成时间意味着新挖掘的块在整个网络中传播的时间更少，并且一个以上的挖掘者找到难题的解决方案的机会更大，因此当块在网络中传播时，一些其他挖掘者也已经解决了难题并广播了它，从而产生了 stales。但是，如果平均块生成时间更长，则多个开采者能够解决难题的机会更小，并且即使他们解决了难题，在他们解决难题的时间之间也可能存在时间差，在此期间，第一个解决的块可以被传播，而其他开采者可以停止开采该块并继续开采下一块。如果陈旧块在网络中频繁出现，它们会导致重大问题，但如果它们很少出现，则不会造成危害。

但是陈旧的块有什么问题呢？嗯，他们会延迟交易的确认。当两个矿工几乎同时开采一个区块时，他们可能没有相同的事务集，所以如果我们的事务出现在其中一个中，我们不能说它被确认，因为出现事务的区块可能是陈旧的。我们应该再等几个街区被开采。由于陈旧块，平均确认时间不等于平均块生成时间。

陈旧的块会影响区块链安全性吗？是的，他们有。我们知道，网络的安全性是由网络中矿工的总计算能力来衡量的。当计算能力增加时，确保块不会早于平均块时间生成的难度也增加了。所以更大的难度意味着更安全的区块链，至于对一个节点的篡改，区块链现在将需要大得多的哈希功率，这使得篡改区块链更加困难；因此，据说区块链更安全。当两个区块几乎同时开采时，我们将网络一分为二，在两个不同的区块链上工作，但其中一个将成为最终的区块链。因此，在旧块上工作的网络部分在旧块之上挖掘下一个块，这最终导致网络的散列能力的损失，因为散列能力被用于不必要的事情。网络的这两个部分可能需要比平均块时间更长的时间来挖掘下一个块，因为它们已经失去了散列能力；因此，在开采下一个区块后，难度将会降低，因为开采该区块所需的时间比平均区块时间要长。难度的降低影响了区块链的整体安全。如果陈旧率过高，将会极大地影响区块链的安全。

以太坊使用一种被称为 ghost 协议的东西来解决陈旧块引起的安全问题。以太坊使用实际 ghost 协议的修改版本。ghost 协议通过简单地将旧块添加到主区块链中来掩盖安全问题，从而增加了区块链的整体难度，因为区块链的整体难度也包括旧块的难度之和。但是如何将陈旧的块插入主区块链而不发生事务冲突呢？任何块都可以指定 0 个或多个 stales。为了激励挖掘者包括陈旧块，挖掘者因包括陈旧块而被奖励。此外，陈旧街区的矿工会得到奖励。陈旧块中的交易不用于计算确认，并且陈旧块挖掘器不接收陈旧块中包括的交易的交易费。注意以太坊把陈旧的块叫做块叔。

这是一个公式来计算一个陈旧区块的矿工得到多少奖励。其余奖励归侄子区块所有，即包含孤儿区块的区块:

```
(uncle_block_number + 8 - block_number) * 5 / 8 

```

由于不奖励陈旧块的矿工不会损害任何安全性，您一定想知道为什么陈旧块的矿工会得到奖励？当陈旧块在网络中频繁出现时，会产生另一个问题，这可以通过奖励陈旧块的挖掘者来解决。一个矿工应该获得一定比例的奖励，类似于他对网络贡献的散列功率的百分比。当两个不同的开采者几乎同时开采一个区块时，由于开采者开采下一个区块的效率，由具有更大散列能力的开采者开采的区块更有可能被添加到最终区块链中；因此，小矿工将失去奖励。如果陈旧率低，这不是一个大问题，因为大矿工会得到一点点增加奖励；但如果过时率很高，就会引发一个大问题，即网络中的大矿工最终会获得比其应得的多得多的奖励。ghost 协议通过奖励陈旧块的挖掘者来平衡这一点。由于大矿工没有得到所有的奖励，但比它应该得到的多得多，我们没有像奖励侄子块一样奖励陈旧的块矿工；相反，我们奖励较少的金额来平衡它。前面的公式很好地平衡了这一点。

Ghost 限制了 nephew 可以引用的陈旧块的总数，这样矿工就不会简单地挖掘陈旧块并拖延区块链。

因此，无论陈旧块出现在网络中的什么地方，它都会对网络产生一定的影响。陈旧块出现的频率越高，网络受其影响就越大。

# 分支

当节点之间关于区块链的有效性存在冲突时，也就是说，网络中碰巧有多个区块链，并且每个区块链对于一些矿工都是有效的，就称发生了分叉。有三种叉子:普通叉子、软叉子和硬叉子。

常规分叉是由于两个或更多矿工几乎同时发现一个区块而发生的临时冲突。当他们中的一个比另一个更困难时，问题就解决了。

对源代码的更改可能会导致冲突。根据冲突的类型，可能需要散列能力超过 50%的挖掘器升级，或者需要所有挖掘器升级以解决冲突。当它要求拥有 50%以上哈希能力的矿工升级来解决冲突时，它被称为软分叉，而当它要求所有矿工升级来解决冲突时，它被称为硬分叉。软分叉的一个例子是，如果对源代码的更新使旧块/事务的子集无效，那么当超过 50%的散列能力已经升级时，可以解决该问题，使得新的区块链将具有更大的困难，并最终被整个网络接受。硬分叉的一个例子是，如果源代码中的更新是为了改变矿工的奖励，那么所有的矿工都需要升级来解决冲突。

以太坊自发布以来经历了各种软硬叉。

# 创世街区

创世纪区块是区块链的第一个区块。它被分配给 0 号块。这是区块链中唯一一个不引用前一个街区的街区，因为没有前一个街区。它不包含任何事务，因为还没有产生任何以太。

网络中的两个节点只有在它们都具有相同的 genesis 块的情况下才会彼此配对，也就是说，只有在两个对等节点都具有相同的 genesis 块的情况下才会发生块同步，否则它们都会拒绝彼此。一个不同的高难度创世积木不能代替一个低难度的积木。每个节点都生成自己的起源块。对于各种网络，genesis 块被硬编码到客户机中。

# 乙醚名称

以太和其他货币一样有不同的面值。以下是面额:

*   1 乙醚= 100000000000000000 魏
*   1 乙醚= 1000000000000000 Kwei
*   1 乙醚= 1000000000000 毫微当量
*   1 乙醚= 1000000000 千兆瓦
*   1 乙醚= 1000000 萨伯
*   1 乙醚= 1000 芬尼
*   1 乙醚= 0.001 乙醚
*   1 乙醚= 0.000001 立方米
*   1 乙醚= 0.000000001 合计
*   1 乙醚= 0.000000000001 系绳

# 以太坊虚拟机

EVM(或以太坊虚拟机)是以太坊智能合约的字节码执行环境。网络中的每个节点都运行 EVM。所有节点都使用 EVM 执行指向智能合约的所有事务，因此每个节点都执行相同的计算并存储相同的值。仅传送以太的交易也需要一些计算，即找出地址是否有余额并相应地扣除余额。

由于各种原因，每个节点执行事务并存储最终状态。例如，如果有一个智能合同存储了参加聚会的每个人的姓名和详细信息，每当添加一个新人时，就会向网络广播一个新的交易。对于网络中的任何节点来说，要显示参加聚会的每个人的详细信息，它们只需读取合同的最终状态。

每个事务都需要网络中的一些计算和存储。所以，需要有一个交易成本，否则整个网络将充斥着垃圾交易，同样没有交易成本，矿工就没有理由将交易包含在块中，他们将开始挖掘空块。每个事务需要不同的计算量和存储量；所以，每一笔交易都有不同的交易成本。

EVM 有两种实现方式，即字节码 VM 和 JIT-VM。在写这本书的时候，JIT-VM 已经可以使用了，但是它的开发还没有完成。在任一情况下，坚固性代码被编译成字节代码。在 JIT-VM 的情况下，字节码被进一步编译。JIT-VM 比它的对手更有效。

# 气体

气体是计算步骤的测量单位。要求每笔交易包括气体限额和愿意支付的每种气体的费用(即，按计算付费)；矿工可以选择包括交易和收取费用。如果交易使用的气体少于或等于气体限制，则交易进行。如果总气体超过气体限制，则所有改变都被还原，除了交易仍然有效并且费用(即可以使用的最大气体和气体价格的乘积)仍然可以由矿工收集。

矿工决定天然气价格(即每计算价格)。如果交易的气价低于矿商决定的气价，矿商将拒绝开采该交易。汽油价格是以卫为单位的数量。因此，如果天然气价格低于其需求，矿商可以拒绝将交易纳入区块。

EVM 的每一项行动都被分配了一个耗油量的数字。

交易成本影响一个账户可以转移到另一个账户的最大金额。例如，如果一个帐户有五个乙醚余额，它不能将所有五个乙醚转移到另一个帐户，因为如果所有乙醚都被转移，帐户中将没有余额来扣除交易费。

如果一个事务调用了一个约定方法，而该方法发送了一些以太网或调用了一些其他约定方法，则从调用该约定方法的帐户中扣除交易费用。

# 对等发现

对于要成为网络一部分的节点，它需要连接到网络中的一些其他节点，以便它可以广播事务/块并侦听新的事务/块。节点不需要连接到网络中的每个节点；相反，一个节点连接到几个其他节点。这些节点连接到其他几个节点。这样，整个网络就互相连接起来了。

但是，由于没有中央服务器，每个人都可以连接到中央服务器来交换信息，节点如何找到网络中的其他节点呢？以太坊有自己的节点发现协议来解决这个问题，它是基于 Kadelima 协议的。在节点发现协议中，我们有一种特殊的节点叫做引导节点。引导节点维护一段时间内连接到它们的所有节点的列表。他们没有掌握区块链本身。当对等体连接到以太坊网络时，它们首先连接到引导节点，引导节点共享在最近预定义的时间段内连接到它们的对等体的列表。连接对等体然后连接并与对等体同步。

可以有各种以太坊实例，也就是各种网络，每个都有自己的网络 ID。两个主要的以太网是 mainnet 和 testnet。mainnet 是在交易所交易的以太网，而 testnet 是开发人员用来测试的。到目前为止，我们已经了解了关于 mainnet 区块链的一切。

Bootnode 是以太坊引导节点最流行的实现。如果您想托管自己的引导节点，可以使用 bootnode。

# 窃窃私语，蜂拥而至

Whisper 和 Swarm 分别是一个去中心化的通信协议和一个去中心化的存储平台，由以太坊开发者开发。Whisper 是一个分散的通信协议，而 Swarm 是一个分散的文件系统。

Whisper 允许网络中的节点相互通信。它支持广播、用户对用户、加密消息等等。它不是为传输大量数据而设计的。你可以在[https://github.com/ethereum/wiki/wiki/Whisper](https://github.com/ethereum/wiki/wiki/Whisper)了解更多关于 Whisper 的信息，你可以在[https://github.com/ethereum/wiki/wiki/Whisper-Overview](https://github.com/ethereum/wiki/wiki/Whisper-Overview)查看代码示例概述。

Swarm 类似于 Filecoin，也就是说，它主要在技术细节和激励方面有所不同。Filecoin 不惩罚商店，而 Swarm 惩罚商店；因此，这进一步提高了文件的可用性。你一定想知道 swarm 中的激励是如何工作的。它有内部货币吗？实际上，Swarm 没有内部货币，而是使用以太作为激励。以太坊有一个智能合约，可以跟踪激励机制。显然，智能合约无法与 Swarm 通信；相反，swarm 与智能合约进行通信。因此，基本上，你通过智能合同向商店付款，付款在到期后发放给商店。您还可以向智能合同报告文件丢失，在这种情况下，它可以处罚相应的商店。你可以在[https://github.com/ethersphere/go-ethereum/wiki/IPFS-&-Swarm](https://github.com/ethersphere/go-ethereum/wiki/IPFS-&-SWARM)了解更多关于 Swarm 和 IPFS/Filecoin 的区别，在[https://github . com/ether sphere/go-ether eum/blob/bzz-config/bzz/bzz contract/Swarm . sol](https://github.com/ethersphere/go-ethereum/blob/bzz-config/bzz/bzzcontract/swarm.sol)查看智能合约代码。

写这本书的时候，Whisper 和 Swarm 还在开发中；所以，很多事情还是不清楚。

# Geth

Geth(或称为 go-ethereum)是以太坊、耳语和群节点的实现。Geth 可以作为所有这些的一部分，也可以只作为选定的一部分。组合它们的原因是使它们看起来像单个 DApp，并且通过一个节点，客户端可以访问所有三个 dapp。

Geth 是一个 CLI 应用程序。它是用 go 编程语言写的。它适用于所有主要的操作系统。geth 的当前版本还不支持 Swarm，但支持 whisper 的一些特性。在写这本书的时候，geth 的最新版本是 1.3.5。

# 安装 geth

Geth 可用于 OS X、Linux 和 Windows。它支持两种类型的安装:二进制和脚本安装。在写这本书的时候，geth 的最新稳定版本是 1.4.13。让我们看看如何使用二进制安装方法将其安装在各种操作系统中。当您必须修改 geth 源代码中的某些内容并安装它时，可以使用脚本安装。我们不想对源代码做任何更改，因此，我们将使用二进制安装。

# x 是什么

在 OS X 安装 geth 的推荐方式是使用 brew。在终端中运行这两个命令来安装 geth:

```
brew tap ethereum/ethereum 
brew install ethereum  

```

# 人的本质

在 Ubuntu 中安装 geth 的推荐方式是使用`apt-get`。在 Ubuntu 终端中运行这些命令来安装 geth:

```
sudo apt-get install software-properties-common 
sudo add-apt-repository -y ppa:ethereum/ethereum 
sudo apt-get update 
sudo apt-get install ethereum

```

# Windows 操作系统

Geth 是 Windows 的可执行文件。从[https://github . com/ether eum/go-ether eum/wiki/Installation-instructions-for-Windows](https://github.com/ethereum/go-ethereum/wiki/Installation-instructions-for-Windows)下载 zip 文件，并解压。在里面，你会找到`geth.exe`文件。

要了解更多关于在各种操作系统上安装 geth 的信息，请访问[https://github . com/ether eum/go-ether eum/wiki/Building-ether eum](https://github.com/ethereum/go-ethereum/wiki/Building-Ethereum)。

# JSON-RPC 和 JavaScript 控制台

Geth 提供 JSON-RPC API 供其他应用程序与之通信。Geth 使用 HTTP、WebSocket 和其他协议为 JSON-RPC API 提供服务。JSON-RPC 提供的 API 分为以下几类:admin、debug、eth、miner、net、personal、shh、txpool 和 web3。你可以在这些[https://github . com/ether eum/go-ether eum/wiki/JavaScript-Console](https://github.com/ethereum/go-ethereum/wiki/JavaScript-Console)中找到更多关于它的信息。

Geth 还提供了一个交互式 JavaScript 控制台，使用 JavaScript APIs 以编程方式与它进行交互。这个交互式控制台使用 JSON-RPC over IPC 与 geth 通信。我们将在后面的章节中学习更多关于 JSON-RPC 和 JavaScript APIs 的知识。

# 子命令和选项

让我们通过例子来学习 geth 命令的一些重要的子命令和选项。通过使用 help 子命令，可以找到所有子命令和选项的列表。在接下来的章节中，我们将会看到更多关于 geth 及其命令的内容。

# 连接到 mainnet 网络

默认情况下，以太坊网络中的节点使用`30303`端口进行通信。但是节点也可以监听其他一些端口号。

要连接到 mainnet 网络，您只需要运行`geth`命令。以下是如何显式指定网络 ID 并指定 geth 将存储下载的区块链的自定义目录的示例:

```
    geth --datadir "/users/packt/ethereum" --networkid 1

```

`--datadir`选项用于指定存储区块链的位置。如果没有提供，默认路径是`$HOME/.ethereum`。

`--networkid`用于指定网络 ID。1 是 mainnet 网络的 ID。如果没有提供，默认值为 1。testnet 的网络 ID 是 2。

# 创建专用网络

要创建一个专用网络，你只需要给一个随机的网络 ID。专用网络通常是为开发目的而创建的。Geth 还提供了与日志记录和调试相关的各种标志，这在开发过程中非常有用。因此，我们可以简单地使用`--dev`标志来运行一个启用了各种调试和日志标志的私有网络，而不是给出一个随机的网络 ID 并放置各种日志和调试标志。

# 创建帐户

Geth 还允许我们创建帐户，即生成与帐户相关联的密钥和地址。要创建帐户，请使用以下命令:

```
    geth account new

```

当您运行此命令时，会要求您输入密码来加密您的帐户。如果您忘记了密码，就无法访问您的帐户。

要获取本地钱包中所有帐户的列表，请使用以下命令:

```
    geth account list

```

前面的命令将打印所有帐户地址的列表。默认情况下，密钥存储在`--datadir`路径中，但是您可以使用`--keystore`选项来指定不同的目录。

# 采矿

默认情况下，geth 不会开始挖掘。要指示 geth 开始挖掘，只需要提供`--mine`选项。还有一些与采矿相关的其他选项:

```
    geth --mine --minerthreads 16 --minergpus '0,1,2' --etherbase '489b4e22aab35053ecd393b9f9c35f4f1de7b194' --unlock '489b4e22aab35053ecd393b9f9c35f4f1de7b194'

```

这里，除了`--mine`选项，我们还提供了各种其他选项。`--minerthreads`选项指定散列时使用的线程总数。默认情况下，使用八个线程。以太基地是存放采矿所得奖励的地址。默认情况下，帐户是加密的。所以要访问账户中的以太，需要解锁，也就是解密账户。解密用于解密与帐户相关联的私钥。要开始采矿，我们不需要解锁，因为只需要地址来存放采矿奖励。可以使用-unlock 选项解锁一个或多个帐户。通过使用逗号分隔地址，可以提供多个地址。

`--minergpus`用于指定用于挖掘的 GPU。要获得 GPU 列表，请使用`geth gpuinfo`命令。对于每个 GPU，你需要有 1-2 GB 的内存。默认情况下，它不使用 GPU，而是只有 CPU。

# 快速同步

在写这本书的时候，区块链的大小大约是 30 GB。如果您的互联网连接速度较慢，下载它可能需要几个小时或几天的时间。以太坊实现了快速同步算法，可以更快的下载区块链。

快速同步不会下载整个块；相反，它只下载块头、交易收据和最近状态数据库。所以，我们不必下载和重放所有的交易。为了检查区块链完整性，该算法在每个定义的块数之后下载一个完整的块。要了解有关快速同步算法的更多信息，请访问[https://github.com/ethereum/go-ethereum/pull/1889](https://github.com/ethereum/go-ethereum/pull/1889)。

要在下载区块链时使用快速同步，您需要在运行 geth 时使用`--fast`标志。

出于安全原因，快速同步将仅在初始同步期间运行(即，当节点自身的区块链为空时)。节点成功与网络同步后，快速同步将永远禁用。作为一项额外的安全功能，如果快速同步在接近或超过随机支点时失败，作为一项安全预防措施，它将被禁用，节点将恢复到基于块处理的完全同步。

# Ethereum 公事包

以太坊钱包是一个以太坊 UI 客户端，允许你创建账户，发送以太，部署契约，调用契约方法，等等。

以太坊钱包附带 geth 捆绑。当您运行 Ethereum 时，它会尝试找到一个本地 geth 实例并与之连接，如果找不到正在运行的 geth，它会启动自己的 geth 节点。以太坊钱包使用 IPC 与 geth 通信。Geth 支持基于文件的 IPC。

如果您在运行 geth 时更改数据目录，您也将更改 IPC 文件路径。所以要让以太坊钱包找到并连接到你的 geth 实例，你需要使用`--ipcpath`选项将 IPC 文件位置指定到它的默认位置，这样以太坊钱包才能找到；否则以太坊钱包将无法找到它，并将启动自己的 geth 实例。要找到默认的 IPC 文件路径，运行 geth help，它会在`--ipcpath`选项旁边显示默认路径。

访问[https://github.com/ethereum/mist/releases](https://github.com/ethereum/mist/releases)下载以太坊钱包。它适用于 Linux、OS X 和 Windows。就像 geth 一样，它有两种安装模式:二进制和脚本安装。

下图展示了以太坊钱包的样子:

![](img/image_02_001.png)

# 下雾

Mist 是以太坊、耳语和蜂群的客户端。它让我们发送交易，发送密语信息，检查区块链，等等。

Mist 和 geth 的关系类似于以太坊钱包和 geth 的关系。

Mist 最受欢迎的特点是自带浏览器。目前浏览器中运行的前端 JavaScript 可以使用`web3.js`库(一个提供以太坊控制台的 JavaScript APIs 供其他应用程序与 geth 通信的库)访问 geth 节点的 web3 APIs。

Mist 的基本思想是构建第三代 web (Web 3.0)，它将通过使用以太坊、耳语和 Swarm 来取代集中式服务器，从而消除对服务器的需求。

这是一张图片，展示了薄雾的样子:

![](img/image_02_002.png)

# 弱点

每个系统都有一些弱点。同样，以太坊也有一些弱点。显然，就像任何其他应用程序一样，以太坊源代码也可能会有 bug。就像任何其他基于网络的应用程序一样，以太坊也暴露在 DoS 攻击之下。但是让我们看看以太坊独特的也是最重要的弱点。

# 西比尔发作

攻击者可以试图用他控制的常规节点填充网络；然后，您很可能只连接到攻击者节点。一旦您连接到攻击者节点，攻击者可以拒绝中继来自每个人的块和事务，从而断开您与网络的连接。攻击者只能中继他创建的块，从而将您置于一个单独的网络中，等等。

# 51%的攻击

如果攻击者控制了一半以上的网络哈希速率，攻击者生成块的速度会比网络的其余部分更快。攻击者可以简单地保存他的私有分支，直到它变得比诚实网络建立的分支更长，然后广播它。

凭借超过 50%的哈希能力，挖掘者可以反转事务，防止所有/部分事务被挖掘，并防止其他挖掘者的挖掘块被插入区块链。

# 宁静

宁静是以太坊下一个重大更新的名字。在写这本书的时候，serenity 还在开发中。此更新将需要一个硬分叉。Serenity 将把共识协议改为 casper，并将整合状态通道和分片。这些将如何工作的完整细节目前还不清楚。让我们看看这些是什么的高级概述。

# 支付和国家渠道

在进入国家渠道之前，我们需要知道什么是支付渠道。支付通道是一种功能，允许我们将两个以上的向另一个帐户汇款的交易合并为两个交易。这是它的工作原理。假设 X 是某视频流媒体网站的所有者，Y 是用户。x 每分钟充一个乙醚。现在 X 想让 Y 在看视频时每分钟后付费。当然，Y 可以每分钟广播一次交易，但这里有几个问题，比如 X 要等待确认，所以视频会暂停一段时间，等等。这是支付渠道解决的问题。利用支付渠道，Y 可以通过广播锁定交易，为 X 锁定一段时间(可能是 24 小时)的一些以太(可能是 100 以太)。现在，在观看 1 分钟的视频后，Y 将发送一个签名记录，表明锁可以解锁，一个乙醚将进入 X 的帐户，其余的进入 Y 的帐户。再过一分钟，Y 会发来一条签字记录，表示可以开锁，两乙醚到 X 的账户，剩下的到 Y 的账户。当 Y 在 X 的网站上观看视频时，这个过程将继续进行。现在一旦 Y 看了 100 个小时的视频或 24 个小时的时间即将到达，X 就会向网络广播最后签署的记录，以向他的账户提取资金。如果 X 未能在 24 小时内提取，则全额退款给 y。因此，在区块链中，我们将只看到两个交易:锁定和解锁。

支付通道用于与发送以太网相关的交易。类似地，状态通道允许我们组合与智能合约相关的事务。

# 利害关系证明和卡斯帕

在我们进入什么是 casper 共识协议之前，我们需要了解利害关系证明共识协议是如何工作的。

利害关系证明是工作证明最常见的替代方法。工作证明浪费了太多的计算资源。POW 和 POS 的区别在于，在 POS 中，一个矿工不需要解谜；取而代之的是，矿商需要证明其对该区块的所有权。在 POS 系统中，账户中的乙醚被视为股份，矿工开采区块的概率与矿工持有的股份成正比。因此，如果矿商持有网络中 10%的股份，它将开采 10%的区块。

但问题是我们如何知道谁将开采下一个区块？我们不能简单地让持股最高的矿商开采下一个区块，因为这将造成集中化。下一个块选择有各种算法，例如随机块选择和基于硬币年龄的选择。

Casper 是 POS 的修改版本，它解决了 POS 的各种问题。

# 分片

目前每个节点都需要下载所有的交易，数量巨大。按照区块链规模增长的速度，在未来几年内，将很难下载整个区块链并保持同步。

如果您熟悉分布式数据库架构，那么您必须熟悉分片。如果不是，那么分片是一种在多台计算机上分发数据的方法。以太坊将实现分片，在节点间划分和分布区块链。

你可以在 https://github.com/ethereum/wiki/wiki/Sharding-FAQ 了解更多关于区块链的知识。

# 摘要

在这一章中，我们详细了解了以太坊的工作原理。我们了解了块时间如何影响安全性，以及以太坊的弱点。我们也看到了什么是 Mist 和以太坊钱包，以及如何安装。我们还看到了 geth 的一些重要命令。最后，我们了解了以太坊宁静更新的新内容。

在下一章，我们将学习储存和保护乙醚的各种方法。