# 对称密码术

在本章中，您将了解到*对称加密*的概念、理论和实践方面。我们将更多地关注与区块链技术相关的元素。我们将为你提供理解后面章节内容所需的概念。

还将向您介绍加密算法的应用，以便您可以在加密功能的实际实现中获得实践经验。为此，我们将使用OpenSSL命令行工具。在开始学习理论基础之前，我们将在下一节看看OpenSSL的安装，这样您就可以在阅读概念材料时做一些实际工作。

# 使用OpenSSL命令行

在Ubuntu Linux发行版上，OpenSSL通常已经可用。但是，可以使用以下命令安装它:

```
$ sudo apt-get install openssl  
```

本章中的示例是使用OpenSSL版本1.0.2g开发的。

在[https://packages.ubuntu.com/xenial/openssl](https://packages.ubuntu.com/xenial/openssl)有售。

我们鼓励您使用这个特定的版本，因为本章中的所有示例都是用它开发和测试的。可以使用以下命令检查OpenSSL版本:

```
$ openssl version  
```

您将看到以下输出:

```
OpenSSL 1.0.2g  1 Mar 2016  
```

现在，你已经准备好运行本章提供的例子了。如果您运行的版本不是1.0.2g，这些示例可能仍然有效，但这并不保证，因为旧版本缺少示例中使用的功能，而新版本可能无法向后兼容1.0.2g版本。

在接下来的章节中，我们将首先讨论密码学的理论基础，然后介绍一系列相关的实际实验。

# 介绍

**密码学**是一门在敌人面前确保信息安全的科学。它这样做是基于对手可以获得无限资源的假设。**密码**是用于加密或解密数据的算法，因此如果被对手截获，在没有**解密**的情况下，数据对他们来说毫无意义，解密需要秘密密钥。

密码术主要用于提供保密服务。就其本身而言，它不能被认为是一个完整的解决方案，而是作为一个更广泛的安全系统中的一个关键构件来解决安全问题。例如，保护区块链生态系统需要许多不同的加密原语，如哈希函数、对称密钥加密、数字签名和公钥加密。

除了机密性服务，加密还提供其他安全服务，如完整性、身份验证(实体身份验证和数据源身份验证)和不可否认性。此外，还提供了责任，这是许多安全系统的要求。

在进一步讨论加密之前，需要解释一些数学术语和概念，以便为全面理解本章后面提供的材料打下基础。

下一节是对这些概念的基本介绍。用证据和相关背景来解释所有这些术语需要一些复杂的数学知识，这超出了本书的范围。关于这些主题的更多细节可以在任何标准数论、代数或密码学的书籍中找到。例如，*尼尔·科布利茨*的*数论和密码学课程*提供了所有相关数学概念的精彩展示。

# 数学

由于密码学的主题是以数学为基础的，这一节将介绍一些基本概念，帮助你理解本章后面介绍的概念。

# 一组

一个**集合**是不同对象的集合，例如 *X = {1，2，3，4，5}* 。

# 组

一个**群**是一个交换集合，其中有一个运算组合了集合中的两个元素。分组操作是封闭的，并且与定义的标识元素相关联。此外，集合中的每个元素都有一个逆元素。**闭包** (closed)是指，例如，如果元素 *A* 和 *B* 在集合中，那么在对这些元素执行运算后得到的元素也在集合中。**关联**表示元素的分组不影响运算的结果。

# 田

一个**域**是包含加法群和乘法群的集合。更准确地说，集合中的所有元素形成一个加法和乘法组。它满足加法和乘法的特定公理。对于所有的集团运作来说，**分配法则**同样适用。该定律规定，即使任何一项或因子被重新排序，也会产生相同的和或积。

# 有限域

一个**有限域**是一个具有有限元素集的域。也被称为*伽罗瓦域*，这些结构在密码学中特别重要，因为它们可以用来产生精确无误的算术运算结果。比如在**椭圆曲线密码** ( **ECC** )中使用素数有限域来构造离散对数问题。

# 命令

**顺序**是一个字段中元素的数量。它也被称为字段的*基数*。

# 阿贝尔群

当集合的元素上的运算是可交换的时，就形成了一个**阿贝尔群**。交换律是指改变元素的顺序不影响运算的结果，例如*A×B = B×A*。

# 主要字段

一个**素数域**是一个有素数个元素的有限域。它有特定的加法和乘法规则，域中每个非零元素都有一个逆。以 *p* 为模进行加法和乘法运算，即素数。

# 戒指

如果在一个阿贝尔群上可以定义一个以上的运算，那么这个群就成为一个**环**。还有需要满足的特定属性。环必须具有闭包、结合和分配性质。

# 循环群

**循环群**是一种可以由称为*群生成器*的单个元素生成的群。

# 模运算

也称为时钟算术，模算术中的数字在达到某个固定数时会回绕。这个定数是一个叫做**模数**的正数，所有的操作都是围绕这个定数进行的。类似于时钟，有从1到12的数字。当它达到12时，数字1又开始了。换句话说，这种类型的算法处理除法运算后的余数。例如，50 mod 11是6，因为50 / 11剩下6的余数。

这就完成了对密码学中涉及的一些数学概念的基本介绍。在下一节中，将向您介绍密码学概念。

# 密码系统

下图显示了一个通用加密模型:

![](assets/dbcedd07-c692-4ff9-8c42-4bf6227835e1.png)

通用加密和解密模型的模型

在上图中， **P** 、 **E** 、 **C** 和 **D** 分别代表明文、加密、密文和解密。同样基于该模型，对诸如实体、发送者、接收者、对手、密钥和信道等概念的解释如下:

*   **实体**:发送、接收数据或对数据执行操作的人或系统
*   **发送方**:这是一个传输数据的实体
*   **接收方**:这是接收数据交付的实体
*   **对手**:这是一个试图绕过安全服务的实体
*   **密钥**:密钥是用于加密或解密其他数据的数据
*   **信道**:信道提供了实体间通信的媒介

接下来，我们将更详细地描述本章前面提到的加密服务。

# 机密

**保密性**是确保信息只对授权实体可用。

# 完整

**完整性**确保信息仅可由授权实体修改。

# 证明

**认证**提供关于实体身份或消息有效性的保证。

有两种类型的身份验证机制，即实体身份验证和数据源身份验证，这将在下一节中讨论。

# 实体认证

**实体认证**是确保实体当前参与并活跃在通信会话中。传统上，用户会获得一个用户名和密码，用于访问他们正在使用的各种平台。这种做法被称为**单因素认证**，因为只涉及一个因素，即*你知道的东西*，即密码和用户名。由于各种原因，这种类型的认证不是很安全，例如，密码泄露；因此，现在通常使用附加因素来提供更好的安全性。使用额外的技术进行用户识别被称为**多因素认证**(或者如果只使用两种方法，则称为双因素认证)。

这里描述了各种身份验证因素:

*   第一个因素是*你拥有*的东西，比如硬件令牌或者智能卡。在这种情况下，除了登录凭据之外，用户还可以使用硬件令牌来访问系统。这种机制通过要求两个认证因素来保护用户。有权访问硬件令牌并知道登录凭据的用户将能够访问系统。这两个因素都应该可以用来访问系统，从而使这种方法成为双因素身份验证机制。如果硬件令牌丢失，它本身将没有任何用处，除非*你知道*，登录密码也与硬件令牌一起使用。
*   第二个因素是 *something you are* ，利用生物特征识别用户。通过这种方法，用户的指纹、视网膜、虹膜或手的几何形状被用来为认证提供额外的因素。这样，可以确保用户在认证过程中确实在场，因为生物特征对于每个人来说都是唯一的。然而，需要仔细实施以保证高度的安全性，因为一些研究表明，在特定条件下可以绕过生物识别系统。

# 数据源认证

也被称为*消息认证*、**数据来源认证**是确保信息来源确实得到验证的一种保证。数据来源认证保证了数据的完整性，因为如果来源得到证实，那么数据一定没有被改变。各种方法，如**消息认证码** ( **MACs** )和数字签名是最常用的。这些术语将在本章后面详细解释。

# 不可否认性

**不可否认性**是一种保证，即一个实体不能通过提供无可争议的证据来否认以前的承诺或行为。它是一种安全服务，提供特定活动已经发生的明确证据。这个属性在有争议的情况下是很重要的，在这种情况下，一个实体否认了所执行的操作，例如，在电子商务系统上下订单。这项服务在电子交易中生成加密证据，以便在发生争议时，可以将其用作行动的确认。

多年来，不可否认性一直是一个活跃的研究领域。电子交易中的争议是一个常见的问题，需要解决这些争议，以提高消费者对这类服务的信任度。

不可否认协议通常在通信网络中运行，它用于提供网络上的实体(发起者或接收者)已经采取行动的证据。在这种情况下，有两种通信模型可用于将消息从始发方 *A* 传送到接收方 *B* :

*   一条消息直接从始发方 *A* 发送到接收方 *B* 。
*   消息从发起者 *A* 发送到递送代理，然后递送代理将消息递送到接收者 *B* 。

不可否认协议的主要要求是公平性、有效性和及时性。在许多情况下，交易中涉及多个参与者，而不是只有两方。例如，在电子交易系统中，可能会有许多实体，如清算代理、经纪人和交易商参与到一个交易中。在这种情况下，双方不可否认协议是不合适的。为了解决这个问题，**多方不可否认**(**)协议被开发出来。**

 **# 有责任

**责任**是一种保证，表明影响安全的行为可以追溯到责任方。这通常由系统中的日志记录和审计机制提供，在这些系统中，由于业务的性质需要进行详细的审计，例如在电子交易系统中。详细的日志对于跟踪实体的行为是至关重要的，例如当交易被放入带有日期和时间戳的审计记录中时，实体的身份被生成并保存在日志文件中。该日志文件可以选择加密，可以是数据库的一部分，也可以是系统上的独立ASCII文本日志文件。

为了提供前面讨论的所有服务，使用了不同的加密原语，这些原语将在下一节中介绍。

# 密码原语

**密码原语**是安全协议或系统的基本构建模块。在下一节中，将向您介绍对于构建安全协议和系统至关重要的加密算法。一个**安全协议**是通过利用适当的安全机制来实现所需安全目标的一组步骤。使用各种类型的安全协议，例如认证协议、不可否认协议和密钥管理协议。

加密原语的分类可以如下图所示:

![](assets/f0f17718-c660-4182-8942-e4d21ffa7c37.jpg)

密码原语

如密码原语分类图所示，密码主要分为两类:*对称密码*和*非对称密码*。

这些原语将在下一节中进一步讨论。

# 对称密码术

**对称加密**指的是一种加密技术，用于加密数据的密钥与用于解密数据的密钥相同。因此，它也被称为**共享密钥加密**。在通信方之间进行数据交换之前，必须建立或商定密钥。这就是它也被称为**密钥加密**的原因。

对称密码有两种类型:*流密码*和*分组密码*。**数据加密标准** ( **DES** )和**高级加密标准** ( **AES** )是分组密码的典型例子，而RC4和A5是常用的流密码。

# 流密码

**流密码**是使用密钥流逐位(一次一位)对明文应用加密算法的加密算法。流密码有两种类型:*同步流密码*和*异步流密码*:

*   **同步流密码**是那些密钥流仅依赖于密钥的密码
*   **异步流密码**的密钥流也依赖于加密数据

在流密码中，加密和解密是相同的功能，因为它们是简单的模2加法或XOR运算。流密码的基本要求是密钥流的安全性和随机性。从伪随机数发生器到在硬件中实现的真随机数发生器的各种技术已经被开发来产生随机数，并且所有密钥发生器在密码上是安全的是至关重要的:

![](assets/d492d415-dce4-4b32-8648-2ca6f7e0c5e3.jpg)

流密码的操作

# 分组密码

**块密码**是一种加密算法，它将待加密的文本(明文)分解成固定长度的块，并逐块应用加密。分组密码通常使用一种被称为**费斯特尔密码**的设计策略来构建。最近的分组密码，如AES (Rijndael)，已经使用被称为**替换-置换网络** ( **SPN** )的替换和置换的组合来构建。

Feistel密码基于Feistel网络，这是Horst Feistel开发的一种结构。这种结构基于组合多轮重复操作的思想，以实现被称为*混淆*和*扩散*的期望的密码属性。Feistel网络通过将数据分成两个块(左和右)并在迭代中通过键控*轮函数*处理这些块来提供足够的伪随机置换。

混淆使得加密文本和明文之间的关系变得复杂。这是通过替换实现的。实际上，明文中的 *A* 被加密文本中的 *X* 所代替。在现代密码算法中，使用被称为 *S盒*的查找表来执行替换。扩散属性以统计方式将明文扩散到加密数据上。这确保了即使输入文本中的单个比特被改变，也会导致密文中至少一半(平均)比特被改变。即使许多加密和解密的数据对是使用相同的密钥创建的，也需要混淆来使得查找加密密钥非常困难。实际上，这是通过换位或排列来实现的。

使用Feistel密码的一个主要优点是加密和解密操作几乎是相同的，并且只需要颠倒加密过程来实现解密。DES是基于Feistel的密码的主要例子:

![](assets/90896149-efcb-4171-8961-45b0dcbede8d.png)

简单的

分组密码的各种操作模式有**电子码本** ( **ECB** )、**密码分组链接** ( **CBC** )、**输出反馈** ( **OFB** )模式、**计数器** ( **CTR** )模式。这些模式用于指定对明文应用加密函数的方式。这里介绍了分组密码加密的一些模式。

# 块加密模式

在**块加密模式**中，根据所使用的密码类型，明文被分成固定长度的块。然后将加密函数应用于每个块。

以下小节将简要讨论最常见的块加密模式。

# 电子代码簿

**电子密码本** ( **ECB** )是一种基本的操作模式，在这种模式下，加密数据是通过对每个明文块逐一应用加密算法而产生的。这是最直接的模式，但不应在实践中使用，因为它不安全并且会泄露信息:

![](assets/4067bed1-3b81-4233-b4ce-ebf922f13d03.png)

分组密码的电子码本模式

上图显示，我们将明文 **P** 作为分组密码加密函数的输入，同时将密钥 **KEY** 和密文 **C** 作为输出。

# 密码分组链接

在**密码块链接** ( **CBC** )模式下，每个明文块与之前加密的块进行异或运算。CBC模式使用**初始化向量** ( **IV** )来加密第一个块。建议随机选择静脉注射:

![](assets/478cd4c0-65e9-4748-aa0c-109a0c938f28.jpg)

密码块链接模式

# 计数器模式

**计数器** ( **CTR** )模式有效地将分组密码用作流密码。在这种情况下，提供了一个唯一的随机数，该随机数与计数器值连接以产生一个**密钥流**:

![](assets/59ec47c3-5fba-4325-a0ef-edc80c8676dc.png)

计数器模式

还有其他的模式，比如**密码反馈** ( **CFB** )模式、**伽罗瓦计数** r ( **GCM** )模式、**输出反馈** ( **OFB** )模式，也用在各种场景中。

# 密钥流生成模式

在**密钥流生成模式**中，加密函数生成密钥流，然后与明文流进行异或运算以实现加密。

# 消息认证模式

在**消息认证模式**下，加密函数产生一个**消息认证码** ( **MAC** )。MAC是提供完整性服务的加密校验和。使用分组密码生成MAC的最常见方法是CBC-MAC，其中链的最后一个块的一部分被用作MAC。例如，MAC可以用于确保如果消息被未授权的实体修改。这可以通过使用MAC函数用密钥加密消息来实现。接收方一旦接收到合成消息和消息的MAC，就可以通过用密钥对再次接收到的消息进行加密并将其与从发送方接收到的MAC进行比较来进行检查。如果二者匹配，则消息没有被未授权用户修改，从而提供完整性服务。如果二者不匹配，则意味着消息在传输过程中被未经授权的实体修改。

# 加密哈希模式

哈希函数主要用于将消息压缩成固定长度的摘要。在**加密哈希模式**中，分组密码被用作压缩函数来产生明文哈希。

至此，我们已经结束了对分组密码的介绍。在下一节中，将向您介绍目前市场上占主导地位的分组密码AES的设计和机制。

然而，在讨论AES之前，先介绍一些关于导致新AES标准发展的**数据加密标准** ( **DES** )的历史。

# 数据加密标准

**数据加密标准** ( **DES** )由美国**国家标准与技术研究院** ( **NIST** )推出，作为加密的标准算法，在20世纪80年代和90年代被广泛使用。然而，由于技术和密码学研究的进步，它并没有被证明对暴力攻击具有很强的抵抗力。比如1998年7月，**电子前沿基金会** ( **EFF** )用一种叫做EFF DES cracker(或*深度破解*)的专用机器破解DES。

DES使用的密钥只有56位，这引起了一些关注。这个问题随着**三重DES** ( **3DES** 的引入而得到解决，该算法提出通过三个56位密钥和相同次数的DES算法的执行来使用168位密钥，从而使得暴力攻击几乎不可能。然而，其他限制，如缓慢的性能和64位块大小，是不可取的。

# 高级加密标准

2001年，经过公开竞争，密码学家琼·代蒙和文森特·里门发明的一种名为Rijndael的加密算法被NIST标准化为**高级加密标准** ( **AES** )。到目前为止，还没有发现比暴力破解更有效的攻击AES的方法。Rijndael的原始版本允许128位、192位和256位的不同密钥和块大小。然而，在AES标准中，只允许128位的块大小。但是，128位、192位和256位的密钥大小是允许的。

# AES如何工作

在AES算法处理期间，使用多轮修改被称为**状态**的4×4字节数组。完全加密需要10到14轮，这取决于密钥的大小。下表显示了密钥大小和所需的轮数:

| **密钥大小** | **所需回合数** |
| 128位 | 10轮 |
| 192位 | 12发子弹 |
| 256位 | 14发子弹 |

一旦用密码的输入初始化了状态，就在四个阶段中执行四个操作来加密输入。这些阶段是:`AddRoundKey`、`SubBytes`、`ShiftRows`和`MixColumns`:

1.  在`AddRoundKey`步骤中，状态数组与一个子密钥进行异或运算，该子密钥是从主密钥得到的
2.  `SubBytes`是替换步骤，其中使用查找表(S-box)替换状态数组的所有字节
3.  `ShiftRows`步骤用于以循环和递增的方式将状态数组中除第一行之外的每一行向左移动
4.  最后，所有字节在`MixColumns`步骤中以线性方式按列混合

前面的步骤描述了一轮AES。

在最后一轮(10、12或14，取决于密钥大小)，阶段4被替换为`AddRoundKey`，以确保前三个步骤不能简单颠倒:

![](assets/618ac1c8-26d6-4920-a21c-aa8777daea29.jpg)

AES框图，显示了第一轮AES加密。在最后一轮中，不执行混合步骤

各种加密货币钱包使用AES加密来加密本地存储的数据。特别是在比特币钱包中，使用的是CBC模式下的AES-256。

下面是如何使用AES加密和解密的OpenSSL示例:

```
$ openssl enc -aes-256-cbc -in message.txt -out message.bin 
enter aes-256-cbc encryption password:
Verifying - enter aes-256-cbc encryption password:
$ ls -ltr

-rw-rw-r-- 1 drequinox drequinox 14 Sep 21 05:54 message.txt
-rw-rw-r-- 1 drequinox drequinox 32 Sep 21 05:57 message.bin
$ cat message.bin  
```

以下是`message.bin`文件的内容:

![](assets/ae4841d1-48e6-4998-ba1b-ee05acb12353.jpg)

注意`message.bin`是一个二进制文件。有时，出于兼容性/互操作性的原因，希望将这个二进制文件编码成文本格式。可以使用以下命令来实现这一点:

```
$ openssl enc -base64 -in message.bin -out message.b64
$ ls -ltr
-rw-rw-r-- 1 drequinox drequinox 14 Sep 21 05:54 message.txt
-rw-rw-r-- 1 drequinox drequinox 32 Sep 21 05:57 message.bin
-rw-rw-r-- 1 drequinox drequinox 45 Sep 21 06:00 message.b64
$ cat message.b64
U2FsdGVkX193uByIcwZf0Z7J1at+4L+Fj8/uzeDAtJE=  
```

为了解密AES加密的文件，可以使用以下命令。使用前一示例中的`message.bin`示例:

```
$ openssl enc -d -aes-256-cbc -in message.bin -out message.dec 
enter aes-256-cbc decryption password:
$ ls -ltr
-rw-rw-r-- 1 drequinox drequinox 14 Sep 21 05:54 message.txt
-rw-rw-r-- 1 drequinox drequinox 32 Sep 21 05:57 message.bin
-rw-rw-r-- 1 drequinox drequinox 45 Sep 21 06:00 message.b64
-rw-rw-r-- 1 drequinox drequinox 14 Sep 21 06:06 message.dec
$ cat message.dec
Datatoencrypt  
```

敏锐的读者会注意到没有提供IV，尽管除了ECB之外，所有块加密操作模式都需要IV。原因是OpenSSL自动从给定的密码中获得IV。用户可以使用以下开关指定IV:

```
-K/-iv      , (Initialization Vector) should be provided in Hex.  
```

为了从base64解码，使用以下命令。遵循前一示例中的`message.b64`文件:

```
$ openssl enc -d -base64 -in message.b64 -out message.ptx
$ ls -ltr
-rw-rw-r-- 1 drequinox drequinox 14 Sep 21 05:54 message.txt
-rw-rw-r-- 1 drequinox drequinox 32 Sep 21 05:57 message.bin
-rw-rw-r-- 1 drequinox drequinox 45 Sep 21 06:00 message.b64
-rw-rw-r-- 1 drequinox drequinox 14 Sep 21 06:06 message.dec
-rw-rw-r-- 1 drequinox drequinox 32 Sep 21 06:16 message.ptx 
$ cat message.ptx 
```

以下是`message.ptx`文件的内容:

![](assets/fb49b421-d11e-472b-950a-7e6526a3e291.jpg)

OpenSSL支持多种类型的密码。您可以根据前面的示例探索这些选项。下面的屏幕截图显示了支持的密码类型列表:

![](assets/e1c6410b-dd51-48f2-8da5-429647c0c948.png)

显示OpenSSL中可用的丰富库选项的屏幕截图

OpenSSL工具可以用来试验截图中显示的所有密码。

# 摘要

在本章中，我们向您介绍了对称密钥加密。我们从基本的数学定义和密码原语开始。之后，我们向您介绍了流和块密码的概念，以及块密码的工作模式。此外，我们还向您介绍了使用OpenSSL来补充理论概念的实践练习。

在下一章中，我们将介绍公钥密码学，它在区块链技术中被广泛使用，并具有非常有趣的性质。**